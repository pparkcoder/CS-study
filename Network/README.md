##### 순서

1. [GET, POST](https://github.com/pparkcoder/CS-study/tree/master/Network#get--post) - **완료**
2. [Protocol, HTTP, HTTPS](https://github.com/pparkcoder/CS-study/tree/master/Network#Protocol) - **완료**
3. [3-Way handshake](https://github.com/pparkcoder/CS-study/tree/master/Network#3-way-handshake) - **완료**
4. [OSI 7 Layer](https://github.com/pparkcoder/CS-study/tree/master/Network#OSI-7-Layer) - **완료**
5. REST & RESTful
6. UDP/TCP 
7. 공개키, 대칭키
8. 로드 밸런싱
9. URI, URL, URN
10. 웹의 흐름

<br>

<br>

# GET & POST

- GET, POST 둘 다 HTTP 프로토콜을 이용해서 서버에 무언가를 요청할 때 사용하는 방식

<br>

### GET

- 요청하는 데이터가 HTTP Request Message의 Header 부분에 url이 담겨서 전송
- url상에 **?** 뒤에 데이터가 붙어 request를 보내게 됨
- ***url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적***
- ***데이터가 그대로 url에 노출되므로 보안이 취약***

<br>

### POST

- 요청하는 데이터가 HTTP Request Message의 Body 부분에 담겨서 전송
- ***데이터의 크기가 GET 방식보다 크고, 보안면에서 우수***
- ***하지만 보안적인 측면에서 암호화를 하지 않는 이상 GET과 비슷***

<BR>

# Protocol

- 둘 이상의 통신 개체 간에 교환되는 메세지 포맷과 순서뿐 아니라, 메세지의 송수신과 다른 이벤트에 따른 행동들을 정의
- **즉 메세지를 주고받는 양식, 규칙 또는 통신규약**
- 연결된 통로를 통해 시스템간에 메세지를 주고받으려면, ***한쪽에서 보낸 메세지를 반대쪽에서 받았을 때 이해 할 수 있어야 함***
- 통신 모델에서도 상호간의 메세지 규칙들을 정의하게 되고, 계층 모델 형태이다 보니 프로토콜도 ***계층별로 존재***

<br>

# HTTP

- 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 서버와 클라이언트와 간의 요청과 응답을 전송
- 주로 HTML 문서를 주고받는데 쓰임
- TCP(HTTP/1, HTTP/2)와 UDP(HTTP/3)을 사용하며, PORT NUM = 80
- 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 정보를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달함. 이 정보가 출력장치(웹 브라우저)를 통해 사용자에게 나타남

<BR>

### HTTP의 특징

- TCP 기반의 통신 방식
- 비연결 지향
  - 브라우저를 통해 사용자의 요청으로 서버와 접속하여 요청에 대한 응답 데이터를 전송 후 연결을 종료
  - 간단하기 때문에 ***자원이 적게 듬***
  - **연결이 지속적이지 않기 때문에 사용자와 연결 종료 후 추가적인 요청 시 어떤 사용자의 요청인지는 모름**
  - 즉, 여러 사용자가 요청할 시 각각의 사용자 요청을 구분할 수 없어, 제대로 된 응답 데이터를 전송할 수 없음
  - ***해결방법으로는 쿠키, 세션, 히든 폼 필드 등이 존재***

<BR>

### Cookie & Session

- HTTP는 비상태성(Stateless) 프로토콜로 상태 정보를 유지하지 않음
- 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것은 큰 장점이지만, 통신할 때마다 매번 연결 설정을 해야 하며, 이전 요청과 현재 요청이 같은 사용자의 요청인지 알 수 없다는 단점이 존재
- 쿠키와 세션을 통해서 해결 가능
- 저장 위치
  - 쿠기 : 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드 디스크
  - 세션 : 서버의 메모리
- 만료 시점
  - 쿠기 : 저장할 때, expires 속성을 정의하여 무효화 시키면 삭제될 날짜를 지정할 수 있음
  - 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화되기 때문에 정확한 시점을 알 수 없음
- 리소스
  - 쿠기 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원을 사용하지 않음
  - 세션 : 서버에 저장되고, 서버 메모리로 로딩되기 때문에 세션이 생길 때마다 리소스를 차지
- 용량 제한
  - 쿠기 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에, 쿠키로 인해 문제가 발생하는 걸 막고자 도메인 당 20개, 하나의 쿠키당 4KB로 제한
  - 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한이 없음
- 보안
  - 쿠기 : 클라이언트에 저장하기 때문에 보안에 취약
  - 세션 : 서버에 저장하기 때문에 쿠키에 비해서 보안이 우수

<br>

### HTTP의 문제점

- HTTP는 평문(암호회되지 않고 전송 또는 저장된 데이터) 통신이기 때문에 **도청이 가능**
- 통신 상대를 확인하지 않기 때문에 **위장이 가능**
- 완전성을 증명할 수 없기 때문에 **변조가 가능**
- **이러한 문제점을 해결하기 위해 HTTPS가 등장**

<BR>

# HTTPS

- HTTPS는 SSL의 껍질을 덮어쓴 HTTP. 즉 HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아님
- HTTP 통신하는 소켓 부분을 인터넷 상에서 정보를 암호화 하는**SSL(Secure Socket Layer)** or **TLS(Transport Layer Security)**라는 프로토콜로 대체한 것
- HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 **HTTP는 SSL과 통신하고, SSL이 TCP와 통신 함**
- SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있음
- HTTPS의 SSL 에서는 ***대칭키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용***
- 대칭키를 공개키 암호화 빙식으로 교환한 다음, 다음부터의 통신은 대칭키 암호를 사용하는 방식

<BR>

### SSL(Secure Socket Layer)

- Netscape 사에서 웹 서버와 브라우저 사이의 보안을 위해 만들어 짐
- CA(Certificate Authority)라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는데 사용
- 인증서에 포함된 내용
  - 서버측 공개키
  - 공개키 암호화 방법
  - 인증서를 사용한 웹서버의 URL
  - 인증서를 발행한 기관 이름

**모든 웹 페이지에서 HTTPS를 사용해도 될까?**

평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구함. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 됨

하지만 최근에는 H/W의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면, 오히려 HTTPS가 HTTP보다 더 빠르게 동작. 따라서 **웹은 과거의 민감한 정보를 다룰 때만 HTTPS의 의한 암호화 통신을 사용하는 방식에서, 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어 가고 있음**

<br>

# 3-Way handshake

- TCP/IP 프로토콜을 이용하여 통신을 진행할 때, 두 종간 단 **정확한** 데이터 전송을 보장하기 위해 연결을 설정하는 과정
- **실제로 데이터 전달이 시작하기 전에 한쪽이, 다른 한쪽이 준비 되었다는 것을 알 수 있도록 함**

<BR>

**실행 과정**

- SYN : Synchronize Sequence Number
- ACK : Acknowledgement
- Client -> Server : TCP SYN
- Server -> Client : TCP SYN ACK
- Client -> Server : TCP ACK

<br>

![](https://user-images.githubusercontent.com/33534771/75338886-d77ea880-58d2-11ea-84c3-f8b60663f9c6.png)



1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷 전송. 이때 ***클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태***
2. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN flag 가 설정된 패킷을 발송. 이때 ***서버는 클라이언트가 다시 ACK로 응답(전송)하기를 기다리는 SYN_RECEIVED 상태***
3. 클라이언트가 서버에게 ACK를 보내고 이후로ㅜ터는 연결이 이루어지고 데이터가 오고 감. 이때 ***서버는 ESTABLISHED 상태***

<br>

**2-Way가 아닌 3-Way 인 이유**

- TCP는 **양방향 연결**이기 때문에 클라이언트에서 서버에게 자신의 존재를 알리고 패킷을 보낼 수 있는 것처럼, 서버에서도 클라이언트에게 자신의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 하기 때문

<br>

# 4-Way handshake

- TCP/IP 프로토콜을 이용한 통신 과정에서는 3-Way handshake를 통해 연결을 설정, 4-Way handshake를 통해 연결 설정을 해제

<br>

![](https://user-images.githubusercontent.com/33534771/75338959-ef562c80-58d2-11ea-99eb-1c09ec97e83a.png)

**실행 과정**

1. 클라이언트는 서버에게 연결을 종료하겠다는 FIN 전송
2. 서버는 클라이언트의 요청(FIN)에 대한 응답으로 ACK 전송
3. **처리해야 할 자신의 통신이 끝날 때 까지 기다림**
4. 처리해야 할 모든 통신을 끝마쳤다면, 연결을 종료하겠다는 FIN 전송
5. 클라이언트는 FIN 패킷에 대한 확인 응답으로 ACK 전송
6. 클라이언트의 ACK를 받은 서버는 소켓 연결을 close
7. **클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 기다림(TIME_WAIT, Default = 240초)**

<br>

# OSI 7 Layer

### OSI 7 Layer 란

- 국제 표준화 기구에서 **개방형 시스템 상호 연결을 위한 기초 참조 모델**로서 만들어진 계층형 모델
- 현재 네트워크 시스템의 기반이 된 모델이며, 다양한 시스템의 연결은 이 계층 모델을 기반으롵 ㅗㅇ신
- 계층모델에 의해 포로토콜도 계층별로 구성

<br>

![](https://user-images.githubusercontent.com/33534771/74589801-e603cf00-504b-11ea-862c-765c57d3169b.png)

### OSI 7 계층을 나누는 이유

- 중요한 목적은 ***표준과 학습 도구***
- 표준화를 통해 이질적인 포트 문제나, 프로토콜 등으로 인한 문제를 해결하여 비용 절감
- 계층별의 기능과 통신 과정을 단계별로 나누어서 쉽게 알 수 있고, 특정한 고셍 이상이 생기면 그 단계만 수정할 수 있기 때문에 편리

<br>

#### 1. 물리 계층

- **주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 역할**
- 프레임 내부의 각 비트를 한 노드에서 다음 노드로 실제로 이동하는 계층
- 이 계층의 프로토콜들은 데이터 링크 계층에 의존하고, 더 나아가 실제 전송 매체에 의존
- 인터넷의 Ethernet 또한 여러 가지 물리 계층 프로토콜을 갖고 있음
- 각 프로토콜에 따라 비트는 다른 방식으로 링크 반대편으로 이동
- 대표적으로 허브, 리피터, 케이블 등

#### 2. 데이터 링크 계층

- **물리 계층을 통해 송/수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할**
- 전체 프레임을 한 네트워크 요소에서 이웃 네트워크 요소로 이동하는 계층으로 인터넷 같은 경우 Ethernet 프로토콜이 대표적
- Ethernet의 경우 MAC 주소를 이용해 node-to-node, point-to-point로 프레임을 전송
- MAC 주소는 장치가 만들어질 때 물리적으로 할당 받아서 ***변할 수 없는 고유 값***
- 프로토콜에 따라 CRC처럼 데이터의 무결성을 검증 가능
- 대표적으로 스위치, 브릿지 등

#### 3. 네트워크 계층

- **여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할**
- **다양한 길이의 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당**
- 라우터를 통해 이동할 경로를 선택하고, IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달
- **라우팅, 흐름 제어, 오류 제어, 세그멘테이션 등을 수행**
- 데이터 전송에서 우선 순위 등을 통해서 특정 수준의 성능을 보장하는 ***QoS(Quality of Service)***를 제공
- 대표적으로 라우터 등

#### 4. 전송 계층

- **TCP, UPD 프로토콜을 통해 통신을 활성화. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공하는 역할**. 이를 통해 양 끝 단의 사용자들이 데이터를 주고 받을 수 있음
- 메세지의 오류를 제어하며, end-to-end로 ***종단간에 해당하는 지점까지 메세지를 주고 받음***
- **메세지가 클 경우 이를 나눠서 네트워크 계층으로 전달하고, 받은 패킷을 재조립해서 상위 계층으로 전달**
- 이를 Segmentation한다고 하며, 전송 계층의 단위는 Segment
- 나눠지는 크기는 보통 **MTU**(Maximum Transmission Unit)에 따라 결정
- **TCP는 연결 지향형 통신을 제공하고, 패킷의 시퀀스 번호 등을 이용하여 손실, 중복, 순서에 대해 신뢰성을 보장하며 흐름제어, 혼잡제어 등의 서비스를 제공**
- **UDP는 비연결 지향형 통신을 제공하고, 신뢰성, 흐름제어, 혼잡제어를 제공하지 않음**
- 대표적으로 TCP, UDP

#### 5. 세션 계층

- **데이터 교환의 경계와 동기화를 제공하는 역할. 즉 데이터가 통신하기 위한 논리적 연결을 담당하는 역할**
- TCP/IP 세션을 만들고 없애는 책임을 지니고 있음
- ***표현 계층(6 Layer)과 마찬가지로 인터넷의 계층 구조에는 포함되지 않으며, 필요에 따라 응용 계층에서 지원하거나 어플리케이션 개발자가 직접 개발해야 함***
- 소켓프로그램의 서버를 예로 들면, 한 서버는 여러 클라이언트와 동시에 통신 가능
- 그러나 여러 클라이언트를 따로 Map등을 통해 저장해야만 각각의 통신 상태에 따라 데이터를 주거나 받는 선택을 할 수 있음
- 또한 **데이터를 상대방이 보내고 있을 때, 동시에 보낼지에 대한 반이중/전이중 통신을 결정할 수 있음**
- 다만 **전이중 통신을 할 경우, 전송 계층의 프로토콜도 해당하는 서비스를 지원하는 프로토콜로 결정해야 함**
- 대표적으로 API, Socket

#### 6. 표현 계층

- **데이터 표현에 대한 독립성을 제공하고 암호화하는 역할**
- ***인터넷의 계층 구조에는 포함되지 않으며, 필요에 따라 응용 계층에서 지원하거나 어플리케이션 개발자가 직접 개발해야 함***
- 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어줌
- ***해당 계층은 프로토콜이 정해져 있지 않기 때문에***, 인코딩 방법을 결정하고 직접 형태를 변경해서 보내거나 알려줘야 함
- **파일 인코딩, 명령어를 포장, 압축, 암호화 함**
- 대표적으로 JPEG, MPEG 등

#### 7. 응용 계층

- **최종 목적지로 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 역할**
- 많은 프로토콜이 존재하는 계층
- 응용 프로그램과 밀접한 관계를 가지는 프로토콜이 많음
- 사용자 인터페이스, 전자 우편, 데이터 베이스 관리 등의 서비스를 제공
- 대표적으로 HTTP, FTP, DNS 등

<br>

### 데이터 전송의 흐름

![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F25303F355755856B02)

1. 통신하는 프로그램에서는 최초 전송하고자 하는 데이터에 **응용 계층의 프로토콜에 맞는 헤더를 붙이면서 패킷을 만들게 됨**

2. 만들어진 메세지들은 **하위 계층으로 전송되면서 헤더가 붙게되고**, ***데이터 링크 계층의 Ethernet 같은 경우 테일을 뒤에 붙이기도 함***
3. 완성된 비트들은 물리 계층을 통해 전송
4. 인터넷 같은 경우, 전송을 돕는 중간 장비인 ***스위칭, 라우터 등***을 거치게 되는데 이 때, 해당 장비에 맞는 만큼만 헤더를 읽으며 내부 내용을 상위 계층으로 전달하며 해석하고, 다시 그에 맞는 하위 계층 헤더를 붙여서 전송
5. 최종 목적지에 도착한 경우 헤더를 인식하며, 그에 맞는 처리를 하며 상위 계층에 전송하고 최종적으로 데이터가 프로그램에게 전달 

[참고](https://velog.io/@hidaehyunlee/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94-%EC%9B%90%EB%A6%AC-OSI-7%EA%B3%84%EC%B8%B5-%EB%AA%A8%EB%8D%B8%EA%B3%BC-TCPIP-%EB%AA%A8%EB%8D%B8)

<br>





