##### 순서

1. [GET, POST](https://github.com/pparkcoder/CS-study/tree/master/Network#get--post) - **완료**
2. [Protocol, HTTP, HTTPS](https://github.com/pparkcoder/CS-study/tree/master/Network#Protocol) - **완료**
3. [3-Way handshake](https://github.com/pparkcoder/CS-study/tree/master/Network#3-way-handshake) - **완료**
4. [OSI 7 Layer](https://github.com/pparkcoder/CS-study/tree/master/Network#OSI-7-Layer) - **완료**
5. [TCP](https://github.com/pparkcoder/CS-study/tree/master/Network#TCP) - **완료**
6. UDP
7. 공개키, 대칭키
8. 로드 밸런싱
9. URI, URL, URN
10. 웹의 흐름

<br>

<br>

# GET & POST

- GET, POST 둘 다 HTTP 프로토콜을 이용해서 서버에 무언가를 요청할 때 사용하는 방식

<br>

### GET

- 요청하는 데이터가 HTTP Request Message의 Header 부분에 url이 담겨서 전송
- url상에 **?** 뒤에 데이터가 붙어 request를 보내게 됨
- ***url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적***
- ***데이터가 그대로 url에 노출되므로 보안이 취약***

<br>

### POST

- 요청하는 데이터가 HTTP Request Message의 Body 부분에 담겨서 전송
- ***데이터의 크기가 GET 방식보다 크고, 보안면에서 우수***
- ***하지만 보안적인 측면에서 암호화를 하지 않는 이상 GET과 비슷***

<BR>

# Protocol

- 둘 이상의 통신 개체 간에 교환되는 메세지 포맷과 순서뿐 아니라, 메세지의 송수신과 다른 이벤트에 따른 행동들을 정의
- **즉 메세지를 주고받는 양식, 규칙 또는 통신규약**
- 연결된 통로를 통해 시스템간에 메세지를 주고받으려면, ***한쪽에서 보낸 메세지를 반대쪽에서 받았을 때 이해 할 수 있어야 함***
- 통신 모델에서도 상호간의 메세지 규칙들을 정의하게 되고, 계층 모델 형태이다 보니 프로토콜도 ***계층별로 존재***

<br>

# HTTP

- 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 서버와 클라이언트와 간의 요청과 응답을 전송
- 주로 HTML 문서를 주고받는데 쓰임
- TCP(HTTP/1, HTTP/2)와 UDP(HTTP/3)을 사용하며, PORT NUM = 80
- 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 정보를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달함. 이 정보가 출력장치(웹 브라우저)를 통해 사용자에게 나타남

<BR>

### HTTP의 특징

- TCP 기반의 통신 방식
- 비연결 지향
  - 브라우저를 통해 사용자의 요청으로 서버와 접속하여 요청에 대한 응답 데이터를 전송 후 연결을 종료
  - 간단하기 때문에 ***자원이 적게 듬***
  - **연결이 지속적이지 않기 때문에 사용자와 연결 종료 후 추가적인 요청 시 어떤 사용자의 요청인지는 모름**
  - 즉, 여러 사용자가 요청할 시 각각의 사용자 요청을 구분할 수 없어, 제대로 된 응답 데이터를 전송할 수 없음
  - ***해결방법으로는 쿠키, 세션, 히든 폼 필드 등이 존재***

<BR>

### Cookie & Session

- HTTP는 비상태성(Stateless) 프로토콜로 상태 정보를 유지하지 않음
- 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것은 큰 장점이지만, 통신할 때마다 매번 연결 설정을 해야 하며, 이전 요청과 현재 요청이 같은 사용자의 요청인지 알 수 없다는 단점이 존재
- 쿠키와 세션을 통해서 해결 가능
- 저장 위치
  - 쿠기 : 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드 디스크
  - 세션 : 서버의 메모리
- 만료 시점
  - 쿠기 : 저장할 때, expires 속성을 정의하여 무효화 시키면 삭제될 날짜를 지정할 수 있음
  - 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화되기 때문에 정확한 시점을 알 수 없음
- 리소스
  - 쿠기 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원을 사용하지 않음
  - 세션 : 서버에 저장되고, 서버 메모리로 로딩되기 때문에 세션이 생길 때마다 리소스를 차지
- 용량 제한
  - 쿠기 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에, 쿠키로 인해 문제가 발생하는 걸 막고자 도메인 당 20개, 하나의 쿠키당 4KB로 제한
  - 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한이 없음
- 보안
  - 쿠기 : 클라이언트에 저장하기 때문에 보안에 취약
  - 세션 : 서버에 저장하기 때문에 쿠키에 비해서 보안이 우수

<br>

### HTTP의 문제점

- HTTP는 평문(암호회되지 않고 전송 또는 저장된 데이터) 통신이기 때문에 **도청이 가능**
- 통신 상대를 확인하지 않기 때문에 **위장이 가능**
- 완전성을 증명할 수 없기 때문에 **변조가 가능**
- **이러한 문제점을 해결하기 위해 HTTPS가 등장**

<BR>

# HTTPS

- HTTPS는 SSL의 껍질을 덮어쓴 HTTP. 즉 HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아님
- HTTP 통신하는 소켓 부분을 인터넷 상에서 정보를 암호화 하는**SSL(Secure Socket Layer)** or **TLS(Transport Layer Security)**라는 프로토콜로 대체한 것
- HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 **HTTP는 SSL과 통신하고, SSL이 TCP와 통신 함**
- SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있음
- HTTPS의 SSL 에서는 ***대칭키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용***
- 대칭키를 공개키 암호화 빙식으로 교환한 다음, 다음부터의 통신은 대칭키 암호를 사용하는 방식

<BR>

### SSL(Secure Socket Layer)

- Netscape 사에서 웹 서버와 브라우저 사이의 보안을 위해 만들어 짐
- CA(Certificate Authority)라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는데 사용
- 인증서에 포함된 내용
  - 서버측 공개키
  - 공개키 암호화 방법
  - 인증서를 사용한 웹서버의 URL
  - 인증서를 발행한 기관 이름

**모든 웹 페이지에서 HTTPS를 사용해도 될까?**

평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구함. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 됨

하지만 최근에는 H/W의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면, 오히려 HTTPS가 HTTP보다 더 빠르게 동작. 따라서 **웹은 과거의 민감한 정보를 다룰 때만 HTTPS의 의한 암호화 통신을 사용하는 방식에서, 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어 가고 있음**

<br>

# 3-Way handshake

- TCP/IP 프로토콜을 이용하여 통신을 진행할 때, 두 종간 단 **정확한** 데이터 전송을 보장하기 위해 연결을 설정하는 과정
- **실제로 데이터 전달이 시작하기 전에 한쪽이, 다른 한쪽이 준비 되었다는 것을 알 수 있도록 함**

<BR>

**실행 과정**

- SYN : Synchronize Sequence Number
- ACK : Acknowledgement
- Client -> Server : TCP SYN
- Server -> Client : TCP SYN ACK
- Client -> Server : TCP ACK

<br>

![](https://user-images.githubusercontent.com/33534771/75338886-d77ea880-58d2-11ea-84c3-f8b60663f9c6.png)



1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷 전송. 이때 ***클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태***
2. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN flag 가 설정된 패킷을 발송. 이때 ***서버는 클라이언트가 다시 ACK로 응답(전송)하기를 기다리는 SYN_RECEIVED 상태***
3. 클라이언트가 서버에게 ACK를 보내고 이후로ㅜ터는 연결이 이루어지고 데이터가 오고 감. 이때 ***서버는 ESTABLISHED 상태***

<br>

**2-Way가 아닌 3-Way 인 이유**

- TCP는 **양방향 연결**이기 때문에 클라이언트에서 서버에게 자신의 존재를 알리고 패킷을 보낼 수 있는 것처럼, 서버에서도 클라이언트에게 자신의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 하기 때문

<br>

# 4-Way handshake

- ***TCP/IP 프로토콜을 이용한 통신 과정에서는 3-Way handshake를 통해 연결을 설정, 4-Way handshake를 통해 연결 설정을 해제***

<br>

![](https://user-images.githubusercontent.com/33534771/75338959-ef562c80-58d2-11ea-99eb-1c09ec97e83a.png)

**실행 과정**

1. 클라이언트는 서버에게 연결을 종료하겠다는 FIN 전송
2. 서버는 클라이언트의 요청(FIN)에 대한 응답으로 ACK 전송
3. **처리해야 할 자신의 통신이 끝날 때 까지 기다림**
4. 처리해야 할 모든 통신을 끝마쳤다면, 연결을 종료하겠다는 FIN 전송
5. 클라이언트는 FIN 패킷에 대한 확인 응답으로 ACK 전송
6. 클라이언트의 ACK를 받은 서버는 소켓 연결을 close
7. **클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 기다림(TIME_WAIT, Default = 240초)**

<br>

# OSI 7 Layer

### OSI 7 Layer 란

- 국제 표준화 기구에서 **개방형 시스템 상호 연결을 위한 기초 참조 모델**로서 만들어진 계층형 모델
- 현재 네트워크 시스템의 기반이 된 모델이며, 다양한 시스템의 연결은 이 계층 모델을 기반으롵 ㅗㅇ신
- 계층모델에 의해 포로토콜도 계층별로 구성

<br>

![](https://user-images.githubusercontent.com/33534771/74589801-e603cf00-504b-11ea-862c-765c57d3169b.png)

### OSI 7 계층을 나누는 이유

- 중요한 목적은 ***표준과 학습 도구***
- 표준화를 통해 이질적인 포트 문제나, 프로토콜 등으로 인한 문제를 해결하여 비용 절감
- 계층별의 기능과 통신 과정을 단계별로 나누어서 쉽게 알 수 있고, 특정한 고셍 이상이 생기면 그 단계만 수정할 수 있기 때문에 편리

<br>

#### 1. 물리 계층

- **주로 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송하는 역할**
- 프레임 내부의 각 비트를 한 노드에서 다음 노드로 실제로 이동하는 계층
- 이 계층의 프로토콜들은 데이터 링크 계층에 의존하고, 더 나아가 실제 전송 매체에 의존
- 인터넷의 Ethernet 또한 여러 가지 물리 계층 프로토콜을 갖고 있음
- 각 프로토콜에 따라 비트는 다른 방식으로 링크 반대편으로 이동
- 대표적으로 허브, 리피터, 케이블 등

#### 2. 데이터 링크 계층

- **물리 계층을 통해 송/수신되는 정보의 오류와 흐름을 관리하여 안전한 정보의 전달을 수행할 수 있도록 도와주는 역할**
- 전체 프레임을 한 네트워크 요소에서 이웃 네트워크 요소로 이동하는 계층으로 인터넷 같은 경우 Ethernet 프로토콜이 대표적
- Ethernet의 경우 MAC 주소를 이용해 node-to-node, point-to-point로 프레임을 전송
- MAC 주소는 장치가 만들어질 때 물리적으로 할당 받아서 ***변할 수 없는 고유 값***
- 프로토콜에 따라 CRC처럼 데이터의 무결성을 검증 가능
- 대표적으로 스위치, 브릿지 등

#### 3. 네트워크 계층

- **여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할**
- **다양한 길이의 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당**
- 라우터를 통해 이동할 경로를 선택하고, IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달
- **라우팅, 흐름 제어, 오류 제어, 세그멘테이션 등을 수행**
- 데이터 전송에서 우선 순위 등을 통해서 특정 수준의 성능을 보장하는 ***QoS(Quality of Service)***를 제공
- 대표적으로 라우터 등

#### 4. 전송 계층

- **TCP, UPD 프로토콜을 통해 통신을 활성화. 포트를 열어두고, 프로그램들이 전송을 할 수 있도록 제공하는 역할**. 이를 통해 양 끝 단의 사용자들이 데이터를 주고 받을 수 있음
- 메세지의 오류를 제어하며, end-to-end로 ***종단간에 해당하는 지점까지 메세지를 주고 받음***
- **메세지가 클 경우 이를 나눠서 네트워크 계층으로 전달하고, 받은 패킷을 재조립해서 상위 계층으로 전달**
- 이를 Segmentation한다고 하며, 전송 계층의 단위는 Segment
- 나눠지는 크기는 보통 **MTU**(Maximum Transmission Unit)에 따라 결정
- **TCP는 연결 지향형 통신을 제공하고, 패킷의 시퀀스 번호 등을 이용하여 손실, 중복, 순서에 대해 신뢰성을 보장하며 흐름제어, 혼잡제어 등의 서비스를 제공**
- **UDP는 비연결 지향형 통신을 제공하고, 신뢰성, 흐름제어, 혼잡제어를 제공하지 않음**
- 대표적으로 TCP, UDP

#### 5. 세션 계층

- **데이터 교환의 경계와 동기화를 제공하는 역할. 즉 데이터가 통신하기 위한 논리적 연결을 담당하는 역할**
- TCP/IP 세션을 만들고 없애는 책임을 지니고 있음
- ***표현 계층(6 Layer)과 마찬가지로 인터넷의 계층 구조에는 포함되지 않으며, 필요에 따라 응용 계층에서 지원하거나 어플리케이션 개발자가 직접 개발해야 함***
- 소켓프로그램의 서버를 예로 들면, 한 서버는 여러 클라이언트와 동시에 통신 가능
- 그러나 여러 클라이언트를 따로 Map등을 통해 저장해야만 각각의 통신 상태에 따라 데이터를 주거나 받는 선택을 할 수 있음
- 또한 **데이터를 상대방이 보내고 있을 때, 동시에 보낼지에 대한 반이중/전이중 통신을 결정할 수 있음**
- 다만 **전이중 통신을 할 경우, 전송 계층의 프로토콜도 해당하는 서비스를 지원하는 프로토콜로 결정해야 함**
- 대표적으로 API, Socket

#### 6. 표현 계층

- **데이터 표현에 대한 독립성을 제공하고 암호화하는 역할**
- ***인터넷의 계층 구조에는 포함되지 않으며, 필요에 따라 응용 계층에서 지원하거나 어플리케이션 개발자가 직접 개발해야 함***
- 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어줌
- ***해당 계층은 프로토콜이 정해져 있지 않기 때문에***, 인코딩 방법을 결정하고 직접 형태를 변경해서 보내거나 알려줘야 함
- **파일 인코딩, 명령어를 포장, 압축, 암호화 함**
- 대표적으로 JPEG, MPEG 등

#### 7. 응용 계층

- **최종 목적지로 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행하는 역할**
- 많은 프로토콜이 존재하는 계층
- 응용 프로그램과 밀접한 관계를 가지는 프로토콜이 많음
- 사용자 인터페이스, 전자 우편, 데이터 베이스 관리 등의 서비스를 제공
- 대표적으로 HTTP, FTP, DNS 등

<br>

### 데이터 전송의 흐름

![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F25303F355755856B02)

1. 통신하는 프로그램에서는 최초 전송하고자 하는 데이터에 **응용 계층의 프로토콜에 맞는 헤더를 붙이면서 패킷을 만들게 됨**

2. 만들어진 메세지들은 **하위 계층으로 전송되면서 헤더가 붙게되고**, ***데이터 링크 계층의 Ethernet 같은 경우 테일을 뒤에 붙이기도 함***
3. 완성된 비트들은 물리 계층을 통해 전송
4. 인터넷 같은 경우, 전송을 돕는 중간 장비인 ***스위칭, 라우터 등***을 거치게 되는데 이 때, 해당 장비에 맞는 만큼만 헤더를 읽으며 내부 내용을 상위 계층으로 전달하며 해석하고, 다시 그에 맞는 하위 계층 헤더를 붙여서 전송
5. 최종 목적지에 도착한 경우 헤더를 인식하며, 그에 맞는 처리를 하며 상위 계층에 전송하고 최종적으로 데이터가 프로그램에게 전달 

[참고](https://velog.io/@hidaehyunlee/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80-%EC%A0%84%EB%8B%AC%EB%90%98%EB%8A%94-%EC%9B%90%EB%A6%AC-OSI-7%EA%B3%84%EC%B8%B5-%EB%AA%A8%EB%8D%B8%EA%B3%BC-TCPIP-%EB%AA%A8%EB%8D%B8)

<br>

# TCP

- **연결형 서비스**를 지원하는 **전송 계층** 프로토콜
- 1:1 통신 방식, 연결 후 통신
- 인터넷 환경(HTTP, HTTP/2) 에서 기본으로 사용
- **흐름 제어, 오류 제어, 혼잡 제어를 통해 신뢰성을 보장**. 그러나 이 때문에 UDP보다 전송 속도가 느림
- 연속성보다 신뢰성있는 전송이 중요할 때 사용 (WEB 통신, 파일 전송 등)
- **데이터의 전송 순서를 보장하며 수신 여부를 확인 가능 (hand-shaking)**
- 연결의 설정(3-hand-shaking)과 해제(4-hand-shaking)
- ***헤더의 크기가 20B로 큰 편이고, 옵션 필드가 최대 40B로 작음***
- MTU 사이즈에 맞게 데이터를 분리해서 보낼 때, 의미 있는 단위가 아닌 최대 크기만큼식 ByteStream 형태로 분리해서 보냄

----------------------------------------------------------------------------------------------------------------------------------------------------

Ex) 한 줄러 서야 하는 A, B, C라는 사람(패킷)이 서울(송신측)에서 출발하여 부산(수신측)으로 가야한다고 가정

A, B, C가 순차적으로 가는 상황에서 B가 길을 잘못 들어서 분실되었다.

하지만 목적지에서는 A, B, C가 모두 필요한지 모르고 A, C만 보고 다 왔다고 착각할 수 있다. 그렇기 때문에 **A, B, C 라는 패킷에 1, 2, 3이라는 번호를 부여**하여 패킷의 분실 확인 처리를 하기 위해 목적지에서 패킷을 **재조립**한다.

이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 목적지에서 받고 재조립할 수 있게 된다.

---------

<BR>

### 흐름 제어

- 송신측과 수신측 사이의 데이터 처리 속도 차이(흐름)을 해결하기 위한 기법
- 송신측의 전송량 **>** 수신측의 처리량 일 경우, ***전송된 패킷은 수신측의 큐를 넘어서 손실될 수 있기 때문에*** 송신측의 패킷 전송량을 제어하게 됨

1. Stop and Wait (정지 - 대기)
   - **매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷 전송 가능**
   - 비효율
   - Give & Take
2. Sliding Window 
   - Stop and Wait의 비효율성을 개선한 기법
   - 윈도우 : 송신, 수신 스테이션 양쪽에서 만들어진 ***버퍼의 크기***
   - **수신측에서 설정한 윈도우 크기만큼 송신측에서 <u>확인 응답 없이</u> 세그멘트를 전송할 수 있게 하여** 데이터 흐름을 동적으로 조절하는 기법
   - 송신측에서는 **ACK를 수신하지 않더라도 여러 개의 프레임을 연속적으로 전송 가능**
   - 만약 수신측으로부터 ACK라는 프레임을 받게 된다면 송신측은 이전에 보낸 데이터 0,1을 수신측에서 정상적으로 받았음을 알게 되고 송신측의 슬라이딩 윈도우는 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장
   - 0,1,2,3,4,5,6,7,8 -> 0,1 전송 -> 0,1에 대한 ACK 수신 -> 2,3,4,5,6,7,8 -> 2,3 전송 -> . . .

<BR>

### 오류 제어

- **오류 검출과 재전송을 포함**
- ARQ(Automatic Repeat Request, 자동 반복 요청) 기법을 사용해 프레임이 손상되었거나 손실되었을 경우, 재전송을 통해 오류 복구
- ARQ 기법은 흐름 제어 기법과 관련이 있음

1. Stop and Wit ARQ
   - 송신측에서 1개의 프레임을 송신하고, ***수신측에서 수신된 프레임의 에러 유무 판단에 따라 ACK or NAK를 보내는 방식***
   - 식별을 위해 데이터 프레임과 ACK 프레임은 각각 0, 1 번호를 번갈아가며 부여
   - 수신측이 데이터를 받지 못했을 경우, NAK를 보내고 **NAK를 받은 송신측은 데이터를 재전송**
   - 만약, 데이터나 ACK가 분실되었을 경우 일정 간격의 시간을 두고 **타임 아웃이 되면, 송신측은 데이터를 재전송**

2. Go-Back-n ARQ

   - 전송된 프레임이 손상되거나 분실된 경우 그리고 ACK 패킷의 손실로 인한 타임 아웃이 발생한 경우, **확인된 마지막 프레임 이후로 모든 프레임을 재전송**
   - 전송측은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별해야 함
   - AKC : 다음 프레임을 전송
   - NAK : ***손상된 프레임 자체 번호를 반환***

   <BR>

   **재전송 되는 경우**

   (1). NAK 프레임을 받은 경우

   ![](https://user-images.githubusercontent.com/33534771/75339203-6ab7de00-58d3-11ea-973d-a4db4abf52a5.png)

    - 수신측으로 0~5까지의 데이터를 보냈을 경우, 수신측에서 데이터를 받았음을 확인하는 ACK를 중간 중간 보냄
    - 만약 수신측에서 데이터 오류 프레임 3를 발견하고 NAK3를 전송측에 보냈다고 가정
    - NAK3를 받은 전송측은 데이터 프레임 3이 잘못되었다는 것을 알고 데이터를 재전송
    - GBn ARQ의 특징은 데이터를 재전송함. **NAK(n)을 받아 <u>n 데이터 이후의 모든 데이터를 재전송</u>**

   <br>

   (2). 전송 데이터 프레임의 분실

   ![](https://user-images.githubusercontent.com/33534771/75339152-507e0000-58d3-11ea-876e-e29653f9f99e.png)

   - 수신측에서 데이터 1을 받고 다음 데이터로 3을 받게 된다면, 데이터 2를 받지 못하였으므로 수신측에서는 **데이터 3을 폐기하고 데이터 2를 받지 못했다는 NAK2를 전송측에 보냄**
   - NAK를 받은 전송측은 (1)의 경우와 같이 NAK(n) 데이터로부터 모든 데이터를 재전송하며 수신측은 기존에 받았던 데이터 중 NAK(n)으로 보냈던 대상 데이터 이후의 모든 데이터를 폐기하고 재전송 받음

   <br>

   (3). 지정된 타임 아웃 내의 ACK 프레임 분실

   ![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-is-stop-and-wait-protocol-frame-lost-651674a85e7f3953.jpg)

   ​																												<경우 1>

   ![](https://s3.ap-south-1.amazonaws.com/afteracademy-server-uploads/what-is-stop-and-wait-protocol-ack-lost-example-2defd16c2171787e.jpg)

   ​																												<경우 2>

   

   	- 전송측은 분실된 ACK를 다루기 위해 **타이머**를 가지고 있음
   	- 전송측에서 이 타이머의 타임 아웃 동안 수신측으로부터 ACK 데이터를 받지 못했을 경우, **마지막 ACK된 데이터부터 재전송**

<BR>

3. SR(Selective-Reject) ARQ

![](https://i.ytimg.com/vi/ZZSk8KQWEdE/hqdefault.jpg)



- GBn ARQ의 확인된 마지막 프레임 이후의 모든 프레임을 재전송하는 단점을 보완한 기법
- **SR ARQ는 손상된, 손실된 프레임만 재전송**하기 때문에, 별도의 데이터 재정렬을 수행해야 하며, 별도의 버퍼를 필요로 함
- **수신측에 버퍼**를 두어 받은 데이터의 정렬이 필요

<BR>

***GBn ARQ vs SR ARQ***

***GBn ARQ***

- 손상, 분실된 프레임 이후의 모든 프레임을 전송
- 구조가 비교적 간단하고 구현이 단순
- 데이터 폐기 방식을 사용하여 추가적 버퍼가 필요 없음
- 비용이 비교적 저렴

<BR>

***SR ARQ***

- 손상, 분실된 프레임만을 전송
- 구조가 복잡(프레임 재배열 등)
- 폐기 방식을 사용하지 않으므로 순차적이지 않은 프레임을 재배열하기 위한 버퍼가 필요
- 비용 및 유지관리 비용이 증가

<BR>

### 혼잡 제어

- 송신측의 데이터 전달과 네트워크의 데이터 처리 속도를 해결하기 위한 기법
- **한 라우터에게 데이터가 몰려있어 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡만 가중**시켜 오버플로우나 데이터 손실이 발생
- 이러한 **네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어**하는 것이 혼잡 제어

<br>

1. AIMD (Additive Increase Multicative Decrease)

   ![](https://evan-moon.github.io/static/1f8521aeeab86f9056a053a93f69adb1/17d73/aimd.png)

   - 합 증가 / 곱 감소 알고리즘이라고도 불림
   - **처음에 패킷 하나를 보내는 것으로 시작**하여 전송한 패킷이 문제 없이 도착한다면, **Window Size를 1씩 증가시키며 전송**, 만약 <u>패킷 전송을 실패하거나 타임 아웃이 발생하면</u> **Window Size를 절반으로 감소**
   - 여러 호스트가 한 네트워크를 공유하고 있으면, 나중에 진입하는 쪽이 처음에는 불리하지만 시간이 흐르면 평형 상태로 수렴하게 되는 특징 => 공평한 방식
   - ***문제점***은 초기 네트워크의 높은 대역폭을 사용하지 못하고 네트워크가 혼잡해지는 상황을 미리 감지하지 못하여 ***혼잡해지고 나서야 대역폭을 줄이는 방식***

   <br>

2. Slow Start

   ![](https://user-images.githubusercontent.com/33534771/75339337-a6eb3e80-58d3-11ea-8ff1-b99bcc992fca.png)

   - AIMD가 네트워크의 수용량 주변에서는 효율적으로 동작하지만, ***처음에 전송 속도를 올리는 데 시간이 너무 길다는 단점 존재***
   - Slow Start는 AIMD와 마찬가지로 패킷을 하나식 보내는 것부터 시작, **패킷이 문제 없이 도착하면 각각의 ACK 마다 Window Size를 1식 늘림**. 즉 한 주기가 지나면 Window Size 는 2배

   <BR>

   ![](https://user-images.githubusercontent.com/33534771/75339370-bb2f3b80-58d3-11ea-9211-af3ca1e5960b.png)

   - **혼잡 현상이 발생하면 Window Size를 1로 떨어뜨림**
   - 처음에는 네트워크의 수용량을 예측할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느정도 예상할 수 있음
   - 미리 **정해진 임계값(Threshold)에 도달할 때까지는 윈도우의 크기를 2배씩 증가, 그 이후부터는 혼잡 회피 단계로 넘어가며 완만하게 1씩 증가**

   <br>

   **혼잡 회피 (Congestion Avoidance)**

   - 윈도우의 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높아짐
   - 이를 회피하기 위해 **윈도우 크기를 선형적으로 1씩 증가시키는 방법**
   - 수신측으로부터 일정 시간 동안까지 ACK를 수신하지 못한 경우
     - 타임 아웃 발생 : 네트워크 혼잡이 발생했다고 인식
     - 혼잡 상태로 인식된 경우 
       - 윈도우의 크기를 1로 감소
       - **동시에 <u>임계값</u>을 패킷 손실이 발생했을 때의 윈도우 크기의 절반으로 줄임**

   <br>

   **빠른 재전송 (Fast Retransmit)**

   - 수신측에서 패킷을 받을 때, 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK를 보냄. 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보냄
   - 따라서 중간에 패킷 하나가 손실되면 송신측에서는 순번이 중복된 ACK 패킷을 받게 됨. 이것을 감지하면 문제가 되는 순번의 패킷을 재전송
   - 빠른 재전송은 중복된 순번의 패킷을 3개 받으면 재전송
   - 이러한 현상이 일어나는 것은 혼잡이 발생한 것으로 간주하여 Window Size를 절반으로 줄임

   <br>

   **빠른 회복 (Fast Recovery)**

   ![](https://media.cheggcdn.com/media/821/821afe8d-d911-465e-b10d-25a5bdfd4477/phprnGcHR)

   - **혼잡한 상태가 되면 Window Size를 <u>1로 줄이지 않고 절반으로 줄이고</u> 선형 증가시키는 방법**
   - 빠른 회복 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작

   [참고](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)

   <br>



