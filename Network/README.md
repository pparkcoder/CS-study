##### 순서

1. GET, POST - **완료**
2. HTTP, HTTPS - **완료**
3. 3-Way handshake - **완료**
4. OSI 7 Layer
5. REST & RESTful
6. UDP/TCP 
7. 공개키, 대칭키
8. 로드 밸런싱
9. URI, URL, URN
10. 웹의 흐름

<br>

<br>

# GET & POST

- GET, POST 둘 다 HTTP 프로토콜을 이용해서 서버에 무언가를 요청할 때 사용하는 방식

<br>

### GET

- 요청하는 데이터가 HTTP Request Message의 Header 부분에 url이 담겨서 전송
- url상에 **?** 뒤에 데이터가 붙어 request를 보내게 됨
- ***url이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적***
- ***데이터가 그대로 url에 노출되므로 보안이 취약***

<br>

### POST

- 요청하는 데이터가 HTTP Request Message의 Body 부분에 담겨서 전송
- ***데이터의 크기가 GET 방식보다 크고, 보안면에서 우수***
- ***하지만 보안적인 측면에서 암호화를 하지 않는 이상 GET과 비슷***

<BR>

<BR>

# HTTP

- 프로토콜(Protocol) : 컴퓨터나 원거리 통신 장비 사이에서 메세지를 주고 받는 양식과 규칙의 체계. **즉 통신 상호간에 미리 약속된 규칙 및 규약**
- 웹에서만 사용하는 프로토콜로 TCP/IP 기반으로 서버와 클라이언트와 간의 요청과 응답을 전송
- 주로 HTML 문서를 주고받는데 쓰임
- TCP(HTTP/1, HTTP/2)와 UDP(HTTP/3)을 사용하며, PORT NUM = 80
- 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 정보를 요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달함. 이 정보가 출력장치(웹 브라우저)를 통해 사용자에게 나타남

<BR>

<BR>

### HTTP의 특징

- TCP 기반의 통신 방식
- 비연결 지향
  - 브라우저를 통해 사용자의 요청으로 서버와 접속하여 요청에 대한 응답 데이터를 전송 후 연결을 종료
  - 간단하기 때문에 ***자원이 적게 듬***
  - **연결이 지속적이지 않기 때문에 사용자와 연결 종료 후 추가적인 요청 시 어떤 사용자의 요청인지는 모름**
  - 즉, 여러 사용자가 요청할 시 각각의 사용자 요청을 구분할 수 없어, 제대로 된 응답 데이터를 전송할 수 없음
  - ***해결방법으로는 쿠키, 세션, 히든 폼 필드 등이 존재***

<BR>

<BR>

### Cookie & Session

- HTTP는 비상태성(Stateless) 프로토콜로 상태 정보를 유지하지 않음
- 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것은 큰 장점이지만, 통신할 때마다 매번 연결 설정을 해야 하며, 이전 요청과 현재 요청이 같은 사용자의 요청인지 알 수 없다는 단점이 존재
- 쿠키와 세션을 통해서 해결 가능
- 저장 위치
  - 쿠기 : 클라이언트의 웹 브라우저가 지정하는 메모리 또는 하드 디스크
  - 세션 : 서버의 메모리
- 만료 시점
  - 쿠기 : 저장할 때, expires 속성을 정의하여 무효화 시키면 삭제될 날짜를 지정할 수 있음
  - 세션 : 클라이언트가 로그아웃하거나, 설정 시간동안 반응이 없으면 무효화되기 때문에 정확한 시점을 알 수 없음
- 리소스
  - 쿠기 : 클라이언트에 저장되고 클라이언트의 메모리를 사용하기 때문에 서버 자원을 사용하지 않음
  - 세션 : 서버에 저장되고, 서버 메모리로 로딩되기 때문에 세션이 생길 때마다 리소스를 차지
- 용량 제한
  - 쿠기 : 클라이언트도 모르게 접속되는 사이트에 의하여 설정될 수 있기 때문에, 쿠키로 인해 문제가 발생하는 걸 막고자 도메인 당 20개, 하나의 쿠키당 4KB로 제한
  - 세션 : 클라이언트가 접속하면 서버에 의해 생성되므로 개수나 용량 제한이 없음
- 보안
  - 쿠기 : 클라이언트에 저장하기 때문에 보안에 취약
  - 세션 : 서버에 저장하기 때문에 쿠키에 비해서 보안이 우수

<br>

<br>

### HTTP의 문제점

- HTTP는 평문(암호회되지 않고 전송 또는 저장된 데이터) 통신이기 때문에 **도청이 가능**
- 통신 상대를 확인하지 않기 때문에 **위장이 가능**
- 완전성을 증명할 수 없기 때문에 **변조가 가능**
- **이러한 문제점을 해결하기 위해 HTTPS가 등장**

<BR>

<BR>

# HTTPS

- HTTPS는 SSL의 껍질을 덮어쓴 HTTP. 즉 HTTPS는 새로운 애플리케이션 계층의 프로토콜이 아님
- HTTP 통신하는 소켓 부분을 인터넷 상에서 정보를 암호화 하는**SSL(Secure Socket Layer)** or **TLS(Transport Layer Security)**라는 프로토콜로 대체한 것
- HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 **HTTP는 SSL과 통신하고, SSL이 TCP와 통신 함**
- SSL을 사용한 HTTPS는 암호화와 증명서, 안전성 보호를 이용할 수 있음
- HTTPS의 SSL 에서는 ***대칭키 암호화 방식과 공개키 암호화 방식을 혼합한 하이브리드 암호 시스템을 사용***
- 대칭키를 공개키 암호화 빙식으로 교환한 다음, 다음부터의 통신은 대칭키 암호를 사용하는 방식

<BR>

<BR>

### SSL(Secure Socket Layer)

- Netscape 사에서 웹 서버와 브라우저 사이의 보안을 위해 만들어 짐
- CA(Certificate Authority)라 불리는 서드 파티로부터 서버와 클라이언트의 인증을 하는데 사용
- 인증서에 포함된 내용
  - 서버측 공개키
  - 공개키 암호화 방법
  - 인증서를 사용한 웹서버의 URL
  - 인증서를 발행한 기관 이름

**모든 웹 페이지에서 HTTPS를 사용해도 될까?**

평문 통신에 비해서 암호화 통신은 CPU나 메모리 등 리소스를 더 많이 요구함. 통신할 때마다 암호화를 하면 추가적인 리소스를 소비하기 때문에 서버 한 대당 처리할 수 있는 리퀘스트의 수가 상대적으로 줄어들게 됨

하지만 최근에는 H/W의 발달로 인해 HTTPS를 사용하더라도 속도 저하가 거의 일어나지 않으며, 새로운 표준인 HTTP 2.0을 함께 이용한다면, 오히려 HTTPS가 HTTP보다 더 빠르게 동작. 따라서 **웹은 과거의 민감한 정보를 다룰 때만 HTTPS의 의한 암호화 통신을 사용하는 방식에서, 현재 모든 웹 페이지에서 HTTPS를 적용하는 방향으로 바뀌어 가고 있음**



# 3-Way handshake

- TCP/IP 프로토콜을 이용하여 통신을 진행할 때, 두 종간 단 **정확한** 데이터 전송을 보장하기 위해 연결을 설정하는 과정
- **실제로 데이터 전달이 시작하기 전에 한쪽이, 다른 한쪽이 준비 되었다는 것을 알 수 있도록 함**

<BR>

**실행 과정**

- SYN : Synchronize Sequence Number
- ACK : Acknowledgement
- Client -> Server : TCP SYN
- Server -> Client : TCP SYN ACK
- Client -> Server : TCP ACK

<br>

![](https://user-images.githubusercontent.com/33534771/75338886-d77ea880-58d2-11ea-84c3-f8b60663f9c6.png)



1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷 전송. 이때 ***클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태***
2. 서버는 SYN 요청을 받고 클라이언트에게 요청을 수락한다는 ACK와 SYN flag 가 설정된 패킷을 발송. 이때 ***서버는 클라이언트가 다시 ACK로 응답(전송)하기를 기다리는 SYN_RECEIVED 상태***
3. 클라이언트가 서버에게 ACK를 보내고 이후로ㅜ터는 연결이 이루어지고 데이터가 오고 감. 이때 ***서버는 ESTABLISHED 상태***

<br>

**2-Way가 아닌 3-Way 인 이유**

- TCP는 **양방향 연결**이기 때문에 클라이언트에서 서버에게 자신의 존재를 알리고 패킷을 보낼 수 있는 것처럼, 서버에서도 클라이언트에게 자신의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 하기 때문

<br>

<br>

# 4-Way handshake

- TCP/IP 프로토콜을 이용한 통신 과정에서는 3-Way handshake를 통해 연결을 설정, 4-Way handshake를 통해 연결 설정을 해제

<br>

![](https://user-images.githubusercontent.com/33534771/75338959-ef562c80-58d2-11ea-99eb-1c09ec97e83a.png)

**실행 과정**

1. 클라이언트는 서버에게 연결을 종료하겠다는 FIN 전송
2. 서버는 클라이언트의 요청(FIN)에 대한 응답으로 ACK 전송
3. **처리해야 할 자신의 통신이 끝날 때 까지 기다림**
4. 처리해야 할 모든 통신을 끝마쳤다면, 연결을 종료하겠다는 FIN 전송
5. 클라이언트는 FIN 패킷에 대한 확인 응답으로 ACK 전송
6. 클라이언트의 ACK를 받은 서버는 소켓 연결을 close
7. **클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 기다림(TIME_WAIT, Default = 240초)**

<br>

<br>





