## 메모리 구조

![](https://user-images.githubusercontent.com/21440957/64079882-6cd82000-cd28-11e9-8810-2bfe3a4944ef.png)

#### 코드 영역

- 실행할 프로그램의 코드가 저장되는 영역 = 텍스트 영역
- CPU는 코드 영역에 저장된 명령어를 하나씩 가져와서 처리



#### 데이터 영역

- 프로그램의 전역변수와 정적변수가 저장되는 영역
- 데이터 영윽은 프로그램의 시작과 동시에 할당, 프로그램 종료 시 소멸



#### 힙 영역

- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
- C/C++ -> malloc, free, 등
- Java -> **가비지 컬렉터**가 자동으로 해제해 줌
- 메모리의 낮은 주소 에서 높은 주소 방향으로 할당
- 런타임 시 크기가 결정 됨



#### 스택 영역

- 함수의 호출과 관계되는 지역변수 와 매개변수가 저장되는 영역
- 함수의 호출 완료 시 소멸
- 메모리의 높은 주소 에서 낮은 주소 방향으로 할당
- 컴파일 시 크기가 결정 됨



#### 힙 과 스택

- 두 영역은 같은 공간을 공유
- 힙은 메모리의 낮은 주소 (위쪽) 부터 할당, 스택은 메모리의 높은 주소 (아래쪽)부터 할당
- 힙 영역이 크면 스택 영역이 작아지고, 스택 영역이 크면 힙 영역이 작아짐



## 프로세스 vs 스레드

### 프로그램

- 어떤 작업을 위해 실행할 수 있는 파일을 의미



### 프로세스(Process)

- **실행 중인 프로그램** 으로 디스크로부터 메모리에 적재되어 **CPU**의 할당을 받은 작업 단위
- **독립된 메모리 영역을 할당 받음**
- 운영체제로부터 시스템 자원을 할당받음
- 할당받는 시스템 자원 
  - CPU 시간
  - 운영을 위한 주소 공간
  - Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역
- 기본적으로 프로세스마다 최초 **1개**의 스레드를 갖음 => **메인 스레드**
- **한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음**
- 접근을 위해서는 프로세스 간 통신 IPC(Inter-Process Communication) 필요
- IPC란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 방법이나 경로



### 프로세스 제어 블록(Process Control Block, PCB)

- 특정 프로세스에 대한 중요한 정보를 저장하고 있는 **커널 내의 자료구조**
- 운영체제는 **프로세스의 생성과 동시에 고유한 PCB 생성**
- 프로세스는 CPU를 할당받아 작업을 처리하던 중, 프로세스 전환이 발생하면 **진행하던 작업을 PCB에 저장 후 CPU 반환**
- 다시 CPU를 할당받게 되면 PCB에서 저장된 내용을 불러와 **종료 시점부터 다시 작업 수행**

![](https://t1.daumcdn.net/cfile/tistory/2164D3365829BAD527)

- PCB에 저장되는 정보
  - 프로세스 식별자(Process ID, PID) : 프로세스 식별 번호
  - 프로그램 카운터(Program Counter) : 프로세스가 다음에 실행할 명령어의 주소를 가르킴
  - CPU 레지스터
  - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케쥴 큐에 대한 포인터 등
  - 메모리 관리 정보(Memory Information) : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
  - 어카운팅 정보(Accounting Information) : 사용된 CPU시간 등
  - 입출력 정보(I/O Information) : 프로세스에 할당된 입출력 장치들과 열린 파일 목록



### 스레드(Thread)

- **프로세스 내에서 실제로 작업을 수행하는 주체**

- 프로세스의 실행 단위라고 할 수 있으며, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원 공유 가능

![](https://user-images.githubusercontent.com/33534771/77537866-232c6e00-6ee2-11ea-91dc-12dacf688276.png)

- 스레드는 프로세스 내의 Code, Data, Heap 영역은 **다른 스레드와 공유**
  - Code 영역을 공유하기 때문에 한 프로세스 내부의 스레드들은 프로세스가 가지고 있는 함수를 모두 호출 가능
  - Heap, Data 영역을 공유하기 때문에 IPC 없이도 **스레드 간 통신 가능**
- **Stack 영역을 따로 할당 받음** 
  - Stack은 함수 호출 시 전달되는 인자, 되돌아 갈 주소값 및 함수 내에서 선언하는 변수 등을 위한 메모리 공간
  - Stack 영역이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것
  - 따라서 독립적인 실행 흐름을 추가하기 위한 최소 조건
- **PC Register를 따로 할당 받음**
  - PC 값은 스레드가 현재 명령어의 어디까지 수행하였는지를 나타냄
  - CPU 반환 시, 명령어가 어느 부분까지 수행되었는지 기억하기 위함



***프로세스 : 자신만의 고유 공간과 자원을 할당받아 사용하는 작업의 단위***

***스레드 : 프로세스가 할당받은 자원을 이용하는 실행의 단위로, 다른 스레드와 프로세스의 자원과 공간을 공유***



### 멀티 프로세스(Multi Process)

- 하나의 응용프로그램을 ***여러 개의 프로세스로 구성***하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 장점
  - **여러 개의 자식 프로세스 중 하나에 문제 발생 시, 문제가 발생한 자식 프로세스만 죽음 (안전성)**
- 단점
  - Context Switching (문맥 교환) 에서의 오버헤드
    - 프로세스는 각 독립된 메모리 영역을 할당받았기에 공유하는 메모리가 없음
    - 따라서 캐시 메모리 초기화 등 무거운 작업 진행 시, 많은 시간이 소모 되는 등 오버헤드 발생 가능
  - 프로세스 간 통신 IPC(Inter-Process Communication)
    - **한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음**
    - 접근을 위해서는 프로세스 간 통신 필요



### 멀티 스레드(Multi Thread)

- 하나의 응용 프로그램을 ***여러 개의 스레드로 구성***하고 각 스레드가 하나의 작업을 처리하도록 하는 것
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램
- 장점
  - 메모리 공간과 시스템 자원 소모가 줄어듬
  - 스레드 간 통신시, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용해 데이터를 주고 받으므로 통신 방법이 간단
  - Context Switching 시, 캐시 메모리를 비울 필요가 없기에 비용이 적고 빠름
  - **따라서** 시스템의 처리량이 향상되고 자원 소모가 줄어들며, 프로그램의 응답 시간 단축
- 단점
  - 서로 다른 스레드가 Data, Heap 영역 등을 공유하기 때문에, 한 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정이 가능. **즉 자원 공유의 문제 발생**
  - 그렇기 때문에, 멀티 스레딩 환경에서는 **동기화 작업이 필요**
  - **하나의 스레드에 문제가 생기면 전체 프로세스에 영향**



***멀티 스레드 VS 멀티 프로세스***

멀티 스레드

- 멀티 프로세스보다 적은 메모리 공간을 차지
- Context Switching이 빠름
- 오류로 인해 하나의 스레드가 종료되면 전체 스레드 종료
- 동기화 문제



멀티 프로세스

- 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지
- 오류로 인해 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않음



=> **이 두가지는 동시에 여러 작업을 수행한다는 점에서 같지만, 적용해야 하는 시스템에 따라 적합/부적합이 구분됨. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용이 필요**



***멀티 프로세스 대신 멀티 스레드를 사용하는 이유***

![](https://user-images.githubusercontent.com/33534771/77537949-41926980-6ee2-11ea-90eb-569dc64faed5.png)

- 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 효율적
- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
- Context Switching시, 캐시 메모리를 피울 필요가 없기에 비용이 적고 더 빠름 -> 스레드는 Stack영역만 초기화 하면 되기 때문
- 스레드는 프로세스 내의 메모리를 공유하기 때문에 데이터 전달이 간단하여 IPC에 비해 비용이 적고 더 빠름 -> 스레드는 프로세스의 Stack 영역을 제외한 모든 메모리를 공유하기 때문
- 





