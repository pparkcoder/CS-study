***([참고1](https://github.com/WooVictory/Ready-For-Tech-Interview), [참고2](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS), [참고3](https://github.com/pparkcoder/TechnicalNote)을 바탕으로 작성하였으며, 꾸준하게 추가할 예정)***

##### 정리 순서

1. 메모리 구조 - **완료**
2. 프로세스, 스레드 - **완료**
3. Context Switching - **완료**
4. CPU 스케줄링 관련 - **진행 중**
5. 동기화, 비동기화 관련
6. 메모리 관리 (페이징 등)
7. 메모리 단편화
8. 캐시



# 메모리 구조

![](https://user-images.githubusercontent.com/21440957/64079882-6cd82000-cd28-11e9-8810-2bfe3a4944ef.png)

#### 코드 영역

- 실행할 프로그램의 코드가 저장되는 영역 = 텍스트 영역
- CPU는 코드 영역에 저장된 명령어를 하나씩 가져와서 처리



#### 데이터 영역

- 프로그램의 전역변수와 정적변수가 저장되는 영역
- 데이터 영윽은 프로그램의 시작과 동시에 할당, 프로그램 종료 시 소멸



#### 힙 영역

- 사용자에 의해 메모리 공간이 동적으로 할당되고 해제
- C/C++ -> malloc, free, 등
- Java -> **가비지 컬렉터**가 자동으로 해제해 줌
- 메모리의 낮은 주소 에서 높은 주소 방향으로 할당
- 런타임 시 크기가 결정 됨



#### 스택 영역

- 함수의 호출과 관계되는 지역변수 와 매개변수가 저장되는 영역
- 함수의 호출 완료 시 소멸
- 메모리의 높은 주소 에서 낮은 주소 방향으로 할당
- 컴파일 시 크기가 결정 됨



#### 힙 과 스택

- 두 영역은 같은 공간을 공유
- 힙은 메모리의 낮은 주소 (위쪽) 부터 할당, 스택은 메모리의 높은 주소 (아래쪽)부터 할당
- 힙 영역이 크면 스택 영역이 작아지고, 스택 영역이 크면 힙 영역이 작아짐



# 프로세스 vs 스레드

### 프로그램

- 어떤 작업을 위해 실행할 수 있는 파일을 의미



### 프로세스(Process)

- **실행 중인 프로그램** 으로 디스크로부터 메모리에 적재되어 **CPU**의 할당을 받은 작업 단위
- **독립된 메모리 영역을 할당 받음**
- 운영체제로부터 시스템 자원을 할당받음
- 할당받는 시스템 자원 
  - CPU 시간
  - 운영을 위한 주소 공간
  - Code, Data, Stack, Heap의 구조로 되어있는 독립된 메모리 영역
- 기본적으로 프로세스마다 최초 **1개**의 스레드를 갖음 => **메인 스레드**
- **한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음**
- 접근을 위해서는 프로세스 간 통신 IPC(Inter-Process Communication) 필요
- IPC란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 방법이나 경로



### 프로세스 제어 블록(Process Control Block, PCB)

- 특정 프로세스에 대한 중요한 정보를 저장하고 있는 **커널 내의 자료구조**
- 운영체제는 **프로세스의 생성과 동시에 고유한 PCB 생성**
- 프로세스는 CPU를 할당받아 작업을 처리하던 중, 프로세스 전환이 발생하면 **진행하던 작업을 PCB에 저장 후 CPU 반환**
- 다시 CPU를 할당받게 되면 PCB에서 저장된 내용을 불러와 **종료 시점부터 다시 작업 수행**

![](https://t1.daumcdn.net/cfile/tistory/2164D3365829BAD527)

- PCB에 저장되는 정보
  - 프로세스 식별자(Process ID, PID) : 프로세스 식별 번호
  - 프로그램 카운터(Program Counter) : 프로세스가 다음에 실행할 명령어의 주소를 가르킴
  - CPU 레지스터
  - CPU 스케쥴링 정보 : 프로세스의 우선순위, 스케쥴 큐에 대한 포인터 등
  - 메모리 관리 정보(Memory Information) : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함
  - 어카운팅 정보(Accounting Information) : 사용된 CPU시간 등
  - 입출력 정보(I/O Information) : 프로세스에 할당된 입출력 장치들과 열린 파일 목록



### 스레드(Thread)

- **프로세스 내에서 실제로 작업을 수행하는 주체**

- 프로세스의 실행 단위라고 할 수 있으며, 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원 공유 가능

![](https://user-images.githubusercontent.com/33534771/77537866-232c6e00-6ee2-11ea-91dc-12dacf688276.png)

- 스레드는 프로세스 내의 Code, Data, Heap 영역은 **다른 스레드와 공유**
  - Code 영역을 공유하기 때문에 한 프로세스 내부의 스레드들은 프로세스가 가지고 있는 함수를 모두 호출 가능
  - Heap, Data 영역을 공유하기 때문에 IPC 없이도 **스레드 간 통신 가능**
- **Stack 영역을 따로 할당 받음** 
  - Stack은 함수 호출 시 전달되는 인자, 되돌아 갈 주소값 및 함수 내에서 선언하는 변수 등을 위한 메모리 공간
  - Stack 영역이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이고 이는 독립적인 실행 흐름이 추가되는 것
  - 따라서 독립적인 실행 흐름을 추가하기 위한 최소 조건
- **PC Register를 따로 할당 받음**
  - PC 값은 스레드가 현재 명령어의 어디까지 수행하였는지를 나타냄
  - CPU 반환 시, 명령어가 어느 부분까지 수행되었는지 기억하기 위함



***프로세스 : 자신만의 고유 공간과 자원을 할당받아 사용하는 작업의 단위***

***스레드 : 프로세스가 할당받은 자원을 이용하는 실행의 단위로, 다른 스레드와 프로세스의 자원과 공간을 공유***



### 멀티 프로세스(Multi Process)

- 하나의 응용프로그램을 ***여러 개의 프로세스로 구성***하여 각 프로세스가 하나의 작업을 처리하도록 하는 것
- 장점
  - **여러 개의 자식 프로세스 중 하나에 문제 발생 시, 문제가 발생한 자식 프로세스만 죽음 (안전성)**
- 단점
  - Context Switching (문맥 교환) 에서의 오버헤드
    - 프로세스는 각 독립된 메모리 영역을 할당받았기에 공유하는 메모리가 없음
    - 따라서 캐시 메모리 초기화 등 무거운 작업 진행 시, 많은 시간이 소모 되는 등 오버헤드 발생 가능
  - 프로세스 간 통신 IPC(Inter-Process Communication)
    - **한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없음**
    - 접근을 위해서는 프로세스 간 통신 필요



### 멀티 스레드(Multi Thread)

- 하나의 응용 프로그램을 ***여러 개의 스레드로 구성***하고 각 스레드가 하나의 작업을 처리하도록 하는 것
- 웹 서버는 대표적인 멀티 스레드 응용 프로그램
- 장점
  - 메모리 공간과 시스템 자원 소모가 줄어듬
  - 스레드 간 통신시, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용해 데이터를 주고 받으므로 통신 방법이 간단
  - Context Switching 시, 캐시 메모리를 비울 필요가 없기에 비용이 적고 빠름
  - **따라서** 시스템의 처리량이 향상되고 자원 소모가 줄어들며, 프로그램의 응답 시간 단축
- 단점
  - 서로 다른 스레드가 Data, Heap 영역 등을 공유하기 때문에, 한 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정이 가능. **즉 자원 공유의 문제 발생**
  - 그렇기 때문에, 멀티 스레딩 환경에서는 **동기화 작업이 필요**
  - **하나의 스레드에 문제가 생기면 전체 프로세스에 영향**



***멀티 스레드 VS 멀티 프로세스***

***멀티 스레드***

- 멀티 프로세스보다 적은 메모리 공간을 차지
- Context Switching이 빠름
- 오류로 인해 하나의 스레드가 종료되면 전체 스레드 종료
- 동기화 문제



***멀티 프로세스***

- 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지
- 오류로 인해 하나의 프로세스가 죽더라도 다른 프로세스에 영향을 끼치지 않음



=> **이 두가지는 동시에 여러 작업을 수행한다는 점에서 같지만, 적용해야 하는 시스템에 따라 적합/부적합이 구분됨. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용이 필요**



***멀티 프로세스 대신 멀티 스레드를 사용하는 이유***

![](https://user-images.githubusercontent.com/33534771/77537949-41926980-6ee2-11ea-90eb-569dc64faed5.png)

- 프로그램을 여러 개 키는 것보다 하나의 프로그램 안에서 여러 작업을 해결하는 것이 효율적
- 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리 가능
- Context Switching시, 캐시 메모리를 피울 필요가 없기에 비용이 적고 더 빠름 -> 스레드는 Stack영역만 초기화 하면 되기 때문
- 스레드는 프로세스 내의 메모리를 공유하기 때문에 데이터 전달이 간단하여 IPC에 비해 비용이 적고 더 빠름 -> 스레드는 프로세스의 Stack 영역을 제외한 모든 메모리를 공유하기 때문



# Context Switching

- CPU는 한번에 하나의 프로세스만 처리 가능
- 여러 프로세스를 처리해야 하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고, 다음에 진행할 Task의 상태값을 읽어 적용하는 과정
- **즉, 다른 프로세스에게 CPU를 할당해 작업을 수행하는 과정**
- 한 프로세스의 상태는 그 프로세스의 프로세스 제어 블록(PCB)에 기록
- Context Switching 동안에는 다른 작업을 수행할 수 없기 때문에, Context Switching 시간은 오버헤드라고 할 수 있음
- 많은 비용 소모
  - Cache 초기화
  - Memory mapping 초기화
  - 커널 항상 실행
- Context Switching 비용 : 프로세스 > 스레드 
  - 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Stack 영역만 변경하면 됨



![](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/684074/0f1e8498-9405-95aa-e2b9-7ef1f3d0e6e9.png)



### 진행 과정

1. Task의 대부분 정보는 Register에 저장되고 PCB로 관리
2. 현재 실행하고 있는 Task의 상태를 PCB에 저장
3. 다음 실행할 Task의 PCB 정보(프로그램 카운터 등) 을 읽어 Register에 적재 후, CPU가 이전에 진행했던 과정을 연속적으로 수행



### 발생 시점

1. 멀티태스킹
   - Task가 하나의 프로세서 상에서 운영체제의 스케줄링 방식에 따라 조금씩 번갈아가며 수행되는 것
   - 멀티 태스킹 환경에서 프로세스가 할당 받은 시간이 종료되어 프로세스가 사용하던 CPU를 다른 프로세스가 사용할 수 있도록 재배정 할 때 발생
2. 인터럽트 핸들링
   - CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요한 경우 CPU에게 알려 처리할 수 있도록 하는 것
   - 인터럽트 종류
     - I/O request : 입출력 요청
     - time slice expired : CPU 사용시간 만료
     - fork a child : 자식 프로세스를 만듦
     - wait for an interrupt : 인터럽트 처리를 기다림
3. (유저모드 <-> 커널모드 전환)
   - 모드 전환은 그 자체로 Context Switching은 아니지만 운영체제에 따라 발생 가능



# 스케줄러(Scheduler)

- **프로세스들은 자신이 종료될 때까지 수많은 큐를 돌아다님**
- 운영체제는 큐 안에 있는 프로세스 중 하나를 선택해야 하며, 이러한 일을 **스케줄러**가 담당



### 큐(Queue)의 종류

1. Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
2. Ready Queue : 현재 메모리 내에 있으면서 CPU를 할당받아 실행되기를 기다리는 프로세스의 집합
3. Device Queue : Deviece I/O 작업을 대기하고 있는 프로세스의 집합



### 스케쥴러의 종류



![](https://t1.daumcdn.net/cfile/tistory/27033450580366160E?download)



1. **장기 스케줄러(Long-term scheduler or job scheduler)**

- 메모리는 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 대용량 메모리(디스크)에 임시로 저장됨. 이 디스크 내의 저장되어 있는 프로세스 중 어떤 순서로 프로세스를 메모리에 적재할지 결정
- **메모리와 디스크 사이의 스케줄링을 담당**, 호출되는 빈도가 적음
- 디스크와 같은 저장 장치에 작업들을 저장해 놓고 필요할 때 실행할 작업을 Job Queue에서 꺼내 Ready Queue를 통해서 메인 메모리에 적재
- **프로세스의 상태**
  - new -> ready

2. **단기 스케줄러(Short-term scheduler or CPU scheduler)**

- **CPU와 메모리 사이의 스케줄링을 담당**, 장기 스케줄러에 비해 많이 호출됨
- 메모리에 있는 프로세스 중 하나를 선택해서 CPU를 할당
- **즉, Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정**
- Ready Queue에 있는 프로세스 중 **먼저 도착한 프로세스에게 CPU 할당**
- **프로세스의 상태**
  - ready -> running -> waiting -> ready

3.**중기 스케줄러(Medium-term scheduler or Swapper)**

- 시분할 시스템에서 추가로 사용하며, 메모리에 대한 가중을 완화시켜주기 위해 사용
- CPU를 차지하기 위한 경쟁이 심해질 때, 우선순위가 낮은 프로세스들을 잠시 제거한 뒤, 나중에 경쟁이 완화되었을 때 다시 디스크에서 메모리로 불러와 중단되었던 지점부터 실행(**Swapping)**
- 즉, 프로세스들이 서로 CPU를 차지하려고 경쟁이 심해지면 Swapping 기법을 활용하여 메모리를 관리함으로써 너무 많은 프로그램이 동시에 올라가는 것을 조절
- **프로세스의 상태**
  - ready -> suspended

***swap out : 메모리에서 디스크로 잠시 나가는 상태***

***swap in : 디스크에서 메모리로 다시 들어오는 상태***

***suspended***

- 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태,
- 프로세스 전부 디스크로 swap out
- Blocked 상태는 다른 I/O 작업을 기다리는 상태이므로 스스로 ready queue로 돌아갈 수 있지만, **외부적인 이유이기 때문에 suspended 상태는 스스로 돌아갈 수 없음**



# CPU 스케줄러













