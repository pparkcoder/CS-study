# 데이터 베이스

### 용어 정리

#### 테이블 (Table)

- 행과 열로 이루어진 집합
- 일반적인 데이터베이스에서는 행과 열만 있으면 테이블
- **관계형 데이터베이스에서는 특별한 제약을 추가해서 릴레이션 (Relation) 이라고 부름**
- 아래 조건을 충족하는 테이블만이 릴레이션이 될 수 있기 때문에 **모든 릴레이션은 -> 테이블 (O) , 모든 테이블 -> 릴레이션 (X)**
  1. 모든 값은 유일한 값을 가짐
  2. 하나의 릴레이션에서 중복되는 행이 존재하면 안됨

#### 행 (Row)

- 한 객체에 대한 정보를 가짐
- 관계형 데이터베이스에서는 **튜플** 또는 **레코드**라고 부름

#### 열 (Colum)

- 테이블의 속성을 의미하며, 열을 구성하는 값들은 같은 **도메인 (Domain)** 으로 되어 있음
- 관계형 데이터베이스에서는 **속성** 이라고 부름

#### 도메인 (Domain)

- 데이터베이스에서 필드(Field)에 채워질 수 있는 값의 집합
- 도메인이 1에서 10사이의 정수인 속성의 필드에 11이나 -1처럼 도메인을 벗어나는 값 또는 아예 다른 자료형이 들어갈 수 없음

#### 스키마 (Schema)

- 데이터베이스를 구성하는 데이터 개체 (Entity), 속성 (Attribute), 관계 (Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의
- 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 구분
- DBMS는 외부 스키마에 명세된 사용자의 요구를 개념 스키마 형태로 변환하고, 이를 다시 내부 스키마 형태로 변환

![](https://t1.daumcdn.net/cfile/tistory/9936823A5B698C4023) 

1. 외부 스키마
   - **사용자의 입장에서 정의한 데이터베이스의 논리적 구조**
   - 데이터들은 어떤 형식, 구조, 화면을 통해 사용자에게 보여줄 것인가에 대한 명세를 말하며, 하나의 데이터베이스에는 여러 개의 외부 스키마가 있을 수 있음
   - 일반 사용자에게는 질의어를 이용해 DB를 쉽게 사용할 수 있도록 하고 응용 프로그래머는 언어를 사용해 DB에 접근하도록 함
2. 개념 스키마
   - 조직 전체를 관장하는 입장에서 DB를 정의한 스키마
   - **DB에 대한 모든 논리적 구조를 기술하기 때문에 데이터베이스에 하나만 존재하며, 통상 스키마라고 하면 개념 스키마를 의미**
3. 내부 스키마
   - 데이터베이스가 어떻게 저장 장치에 저장될 지에 대한 명세
   - 물리적인 저장 장치와 데이터베이스 간의 관계를 정의하므로 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마

<BR>

### 데이터 베이스

특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

1. 통합된 데이터 (Integrated Data) : 자료의 중복을 배제한 데이터의 모임
2. 저장된 데이터 (Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
3. 운영 데이터 (Operational Data) : 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안될 반드시 필요한 자료
4. 공용 데이터 (Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

### 특징

1. 실시간 접근성 (Real-Time Accessibility) : 수시적이고 비정형적인 질의에 대하여 **실시간 처리 응답이 가능해야 함**
2. 계속적인 변화 (Continuous Evolution) : 데이터베이스의 상태는 동적. 즉 새로운 데이터의 삽입, 삭제, 갱신은 **항상 최신의 데이터를 유지**
3. 동시공용 (Concurrent Sharing) : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로, **다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 함**
4. 내용에 의한 참조 (Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라, **사용자가 요구하는 데이터 내용으로 데이터를 찾음**

<br>

# Key

- 검색이나 정렬 시 Tuple을 구분할 수 있는 기준이 되는 Attribute

![](https://user-images.githubusercontent.com/33534771/75773133-a4d02680-5d90-11ea-8ad0-ac4b85e438d2.png)

### 1. 후보키 (Candidate Key)

- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분 집합을 의미
- **기본키로 사용할 수 있는 속성들**
- **모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 함**
- 릴레이션에 있는 모든 튜플에 대해서 **유일성과 최소성을 만족**시켜야 함
  - 유일성 : key로 하나의 튜플을 유일하게 식별할 수 있음
  - 최소성 : 꼭 필요한 속성으로만 구성

**학생 릴레이션에서 학번이나 주민번호는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키. 즉, 기본키가 될 수 있는 키들을 후보키**

### 2.기본키 (Primary Key)

- **후보키 중 선택한 Main Key**
- 한 릴레이션에서 **특정 튜플을 유일하게 구별할 수 있는 속성**
- **Null 값을 가질 수 없음 (개체 무결성의 첫 번째 조건**
- **기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음 (개체 무결성의 두 번째 조건)**
- 아래 조건을 만족해야 함
  - 유일성 : 기본키를 구성하는 컬럼은 릴레이션에서 레코드를 식별할 수 있도록 유일해야 함
  - 최소성 : 유일성을 만족하는 한도 내에서 최소한의 컬럼으로 구성되어야 함
  - 개체 무결성 : 기본키가 가지고 있는 값의 유일성을 보장받아야 함

**학생 릴레이션에서 학번이나 주민번호가 기본키가 될 수 있고, 수강 릴레이션에는 학번+과목병으로 조합해야 기본키가 만들어 질 수 있음. 왜냐하면 수강 릴레이션에서는 학번 속성과 과목명 속성 각각은 다른 튜플들과 구별되지 않기 때문**

### 3. 대체키 (Alternate Key) , 보조키

- **후보키가 둘 이상일 때, 기본키를 제외한 나머지 후보키**

**학생 릴레이션에서 학번을 키본키로 정하면 주민번호는 대체키**

### 4. 슈퍼키 (Super Key)

- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타내지 않음
- 릴레이션을 구성하는 모든 튜플에 대해서 **유일성은 만족하지만, 최소성은 만족시키지 못함**

**[학생] 릴레이션에서는 학번, 주민번호, 학번+주민번호, 학번+주민번호+성명  등으로 슈퍼키를 구성할 수 있다. 또한, 여기서 최소성을 만족시키지 못한다는 말은  학번+주민번호+성명 이 슈퍼키인 경우, 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만,  성명 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못함**

즉, 뭉쳤을 경우 유일성이 생기고 흩어지면 몇몇 속성들은 독단적으로 유일성이 있는 키로 사용할 수 없음. 이것을 최소성을 만족하지 못한다고 함.

### 5. 외래키 (Foreign Key)

- 관계(Relation)를 맺고 있는 릴레이션 R1,R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성을 외래키라고 한다.
- 외래키는 **참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는 데 중요한 도구로 사용된다**.
- **외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없다**.(참조 무결성의 조건)

[수강] 릴레이션이 [학생] 릴레이션을 참조하고 있으므로, [학생] 릴레이션의 **학번**은 기본키이고, [수강] 릴레이션의 **학번**은 외래키이다.

즉, 각 릴레이션의 입장에서 속성은 기본키가 되기도 하고, 외래키가 되기도 한다.

-> [수강] 릴레이션의 **학번**에는 [학생] 릴레이션의 **학번**에 없는 값은 입력할 수 없다.

<br>

# 쿼리 관련

[SQL문](https://github.com/pparkcoder/TechnicalNote/blob/master/database/DBQuery.md)

[DDL, DML, DCL](https://github.com/pparkcoder/TechnicalNote/blob/master/database/DDLAndDMLAndDCL.md)

# Index

### Index 란

- RDBMS에서 검색 속도를 높이기 위해 사용하는 하나의 기술
- Index는 색인
- 해당 Table의 컬럼을 색인화(따로 파일로 저장)하여 검색시 해당 Table의 레코드를 full scan 하는것이 아니라, 색인화 되어있는 Index 파일을 검색하여 검색 속도를 빠르게 함
- Index 구조는 Tree 구조로 색인화
- RDBMS에서 사용하는 Index는 Balance Search Tree를 사용

### 목적

- RDBMS의 검색 속도를 높이는데 있음
- 특히 SELECT 쿼리의 WHERE 절이나, JOIN 예약어를 사용했을 때만 인덱스를 사용하며, **SELECT 쿼리의 검색 속도를 빠르게 하는게 주요 목적**

### Index의 원리

Index를 해당 컬럼에 주게 되면 초기 Table 생성시, **FRM, MYD, MYI** 3개의 파일이 만들어 짐

- FRM : 테이블 구조가 저장되어 있는 파일
- MYD : 실제 데이터가 있는 파일
- MYI : Index 정보가 들어있는 파일 (Index를 사용하지 않은 경우 해당 파일은 비어져 있음)

### 진행 순서

1. Index를 해당 컬럼에 만들게 되면 해당 컬럼을 따로 인덱싱하여 MYI 파일에 입력함
2. 이후 사용자가 SELECT 쿼리로 Index를 사용하는 쿼리를 사용시 해당 Table을 검색하는 것이 아니라 MYI 파일의 내용을 검색함
3. 만약 Index를 사용하지 않은 SELECT 쿼리라면 해당 Table Full Scan 하여 모두 검색함

### 장점

- 키 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상시킴
- 테이블의 기본키는 자동으로 인덱스 됨

### 단점

- 인덱스를 만들면 .mdb 파일 크기가 늘어남
- 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어듬
- 인덱스된 필드에서 데이터를 업데이트하거나 레코드를 추가 또는 삭제할 때 성능이 떨어짐
- 인덱스가 데이터베이스 공간을 차지해 추가적인 공간이 필요해짐 (DB의 10% 내외의 추가 공간 필요)
- 인덱스를 생성하는데 시간이 많이 소요될 수 있음
- 데이터 변경 작업이 자주 일어날 경우에 인덱스를 재 작성해야 할 필요가 있기에 성능에 영향을 끼칠 수 있음

### 사용하면 좋은 경우

1. **WHERE 절에서 자주 사용되는 컬럼**
2. 외래키가 사용되는 컬럼
3. JOIN에 자주 사용되는 컬럼

### 사용을 피해야 하는 경우

1. Data 중복도가 높은 컬럼
2. DML이 자주 일어나는 컬럼

### DML에 취약

1. INSERT

   - Index split : 인덱스의 블록들이 하나에서 두개로 나누어지는 현상

   - 인덱스는 데이터가 순서대로 정렬되어야 함. 기존 블록에 여유 공간이 없는 상황에서 그 블록에 새로운 데이터가 입력되어야 할 경우, 오라클이 기존 블록의 내용 중 일부를 새 블록에다가 기록한 후, 기존 블록에 빈 공간을 만들어서 새로운 데이터를 추가하게 됨
   - 성능면에서 매우 불리
     - Index split은 새로운 블록을 할당받고 key를 옮기는 복잡한 작업을 수행함. 모든 수행 과정이 Redo에 기록되고 많은 양의 Redo를 유발

2. DELETE

   - 테이블에서 데이터가 Delete 될 경우, **지워지지 않고 다른 데이터가 그 공간을 사용할 수 있음**
   - **index에서 데이터가 Delete 될 경우, 데이터가 지워지지 않고 사용 안됨 표시만 해둠**
   - 즉, 테이블에 데이터가 1만건이 있는 경우, 인덱스에는 2만건이 있을 수 있다는 뜻
   - 수행 속도를 기대하기 힘듬

3. UPDATE

   - 인덱스에는 Update 개념이 없음
   - 테이블에 update가 발생할 경우, **인덱스에서는 delete가 먼저 발생한 후 새로운 작업의 insert 작업이 발생**
   - **delete와 insert 두 개의 작업이 인덱스에서 동시에 일어나 다른 DML 보다 더 큰 부하를 주게 됨**

<BR>

# JOIN

### JOIN 이란

- 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법
- 테이블을 연결하려면 **적어도 하나의 컬럼을 서로 공유하고 있어야** 하므로 이를 이용하여 데이터 검색에 활용

<BR>

### JOIN 종류

1. **INNER JOIN**

![](https://user-images.githubusercontent.com/33534771/75853566-c1706b00-5e31-11ea-83bc-1e2ebe4d9f61.png) 

- 쉽게 말해 **교집합**

- 기준 테이블과 JOIN 한 테이블의 **중복된 값**을 보여줌

- 결과값은 A 테이블과 B 테이블 모두 가지고 있는 데이터만 검색

- 표현 방법

  - **EQUI JOIN (동등조인)**

    - ```sql
      SELECT *
      FROM EMPLOYEE, DEPARTMENT
      WHERE EMPLOYEE.DepartmentID = DEPARTMENT.DepartmentID
      ```

    - 연산자(=) 를 사용해서 EQUI JOIN 이라고 부름

  - **명시적인 표현**

    - ```SQL
      SELECT *
      FROM EMPLOYEE INNER JOIN DEPARTMENT
      ON EMPLOYEE.DepartmentID = DEPARTMENT.DepartmentID
      ```

    - INNER JOIN 표시가 있다면 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에 사용한다는 뜻

    - **USING, ON 조건절을 필수로 사용**

  - **USING 조건절**

    - ```SQL
      SELECT *
      FROM EMP JOIN DEPT USING(DEPTNO)
      ```

    - 원하는 컬럼에 대해서만 선택적으로 EQUI JOIN

    - ALIAS나 테이블 이름과 같은 접두사를 사용할 수 없음

    - USING 조건에는 1개 이상의 컬럼을 정의할 수 있음

  - **ON 조건절**

    - ```SQL
      SELCT T.TEAM_NAME, S.STADIUM_ID, S.STADIUM_NAME
      FROM TEAM T JOIN STADIUM S
      ON(T.STADIUM_ID = S.HOMETEAM_ID); -- STADIUM_ID와 HOMETEAM_ID는 같은 데이터이지만 컬럼 이름이 다름
      ```

    - **컬럼명이 다르더라도 JOIN 조건을 사용할 수 있음**

    - 테이블이 많이 사용될 경우 가독성이 떨어질 수 있음

  <BR>

2. **OUTER JOIN**

- JOIN 조건에서 **테이블간에 한 쪽에만 데이터가 있는 경우, 데이터가 있는 테이블 쪽의 모든 내용을 보여주는 것**

- 조인 조건에 만족하지 않아도 해당 행을 출력하고 싶을 때 사용

- **USING, ON 조건절을 필수적으로 사용**

- **항상 기준이 되는 테이블이 드라이빙 테이블이 됨**. 드라이빙 테이블에 따라 쿼리의 성능이나 튜닝에 많은 영향을 끼치기 때문에 **데이터 양 보다는 적은 데이터를 추출하는 테이블을 드라이빙 테이블로 잡는 것이 중요**

- 드라이빙 테이블 : JOIN이 발생했을 때 첫 번째로 ACCESS되는 테이블

- 표현 방법

  - **LEFT OUTER JOIN**

    - ![](https://user-images.githubusercontent.com/33534771/75853627-e238c080-5e31-11ea-89bb-a5afe1058cfd.png) 

    - 왼쪽 테이블을 기준으로 데이터 출력

    - ```SQL
      SELECT A.NAME, B.AGE
      FROM EX_TABLE A
      LEFT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
      ```

    - **결과값은 A 테이블의 모든 값과 A 테이블과 B 테이블의 중복되는 값이 검색**

  - **RIGHT OUTER JOIN**

    - ![](https://user-images.githubusercontent.com/33534771/75853699-f8468100-5e31-11ea-8c0f-5109f2852c59.png) 

    - 오른쪽 테이블을 기준으로 데이터 출력

    - ```SQL
      SELECT A.NAME, B.AGE
      FROM EX_TABLE A
      RIGHT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
      ```

    - **결과값은 B 테이블의 모든 데이터와 A 테이블과 B 테이블의 중복되는 값이 검색**

  - **FULL OUTER JOIN**

    - ![](https://user-images.githubusercontent.com/33534771/75853732-072d3380-5e32-11ea-8cda-53eb71de966e.png) 

    - 쉽게 말해 **합집합**

    - 사실상, 기준 테이블의 의미가 없음

    - ```SQL
      SELECT A.NAME, B.AGE
      FROM EX_TABLE A
      FULL OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
      ```

    -  **A 테이블이 가지고 있는 데이터, B 테이블이 가지고 있는 데이터 모두 검색됨**

    - 중복되는 데이터는 삭제

<BR>

### CROSS JOIN , CROSS PRODUCT

![](https://user-images.githubusercontent.com/33534771/75853764-16ac7c80-5e32-11ea-9942-04adab33ddb2.png) 

- **모든 경우의 수를 전부 표현해주는 방식**
- 기준 테이블이 A일 경우, A의 데이터 한 ROW를 B 테이블 전체와 JOIN 하는 방식
- 결과값은 **N*M**

```SQL
-- 첫 번째 방식 --
SELECT A.NAME, B.AGE
FROM EX_TABLE A
CROSS JOIN JOIN_TABLE B
-- 두 번째 방식 --
SELECT A.NAME, B.AGE
FROM EX_TABLE A, JOIN_TABLE B
```

<BR>

### SELF JOIN, 자가 JOIN

![](https://user-images.githubusercontent.com/33534771/75853799-2926b600-5e32-11ea-94ce-4974aade41ca.png) 

- 자기 자신과 자기 자신을 조인한다는 의미

- 하나의 테이블을 여러번 복사해서 조인한다고 생각

- 자신이 가지고 있는 컬럼을 다양하게 번형시켜 활용할 경우에 자주 사용

- ```SQL
  SELECT e.empno, e.ename, e.job, e.sal, m.empno, m.ename, m.job
  FROM emp e INNER JOIN emp m ON e.mgr = m.empno
  ```

<br>

# 정규화

### 이상 종류

Ex. Student ID, Course ID, Department, Course, Grade

- 이상 : 데이터 중복으로 인해 릴레이션 조작 시 예상하지 못한 곤란한 현상

1. 삽입 이상 (Insertion Anomaly)
   - 원하지 않는 자료가 삽입된다든지, 삽입하는데 자료가 부족해 삽입이 되지 않아 발생하는 문제점
   - 기본키가 Student ID, Course ID인 경우(복합키 인 경우), Course를 수강하지 않은 학생은 Course ID가 없는 현상이 발생. 결국 Course ID를 Null로 할 수 밖에 없는데, 기본키는 Null이 될 수 없으므로 테이블에 추가될 수 없음
   - 굳이 삽입하기 위해서는 '미수강' 같은 Course ID를 만들어야 함

**불필요한 데이터를 추가해야 삽입할 수 있는 상황**이 삽입 이상

2. 삭제 이상 (Deletion Anomaly)
   - **하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜플 전체가 삭제됨으로 원하지 않는 정보 손실이 발생하는 문제점**
   - 만약 어떤 학생이 수강을 철회하는 경우, {Student ID, Course ID, Department, Course, Grade}의 정보 중 Course ID를 삭제하면 Student ID, Department와 같은 학생에 대한 정보도 함께 삭제

**튜플 삭제로 인해 꼭 필요한 데이터까지 함께 삭제되는 문제**가 삭제 이상

3. 갱신 이상 (Update Anomaly)
   - 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어져 정확한 정보 파악이 되지 않는 문제점
   - 만약 어떤 학생의 전공 (Department)이 '컴퓨터' -> '음악'으로 바뀌는 경우, 모든 Department를 '음악'으로 바꾸어야 함
   - **그러나 일부를 깜빡하고 바꾸지 못한 경우, 제대로 파악하지 못함**

**일부만 변경하여 데이터가 불일치하는 모순의 문제**가 갱신 이상

<br>

### 정규화 란

관계형 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업. 좀 더 구체적으로는 불만족스러운 **나쁜 릴레이션의 애트리뷰트들을 나누어서 좋은 작은 릴레이션으로 분해하는 작업을 말함**. 정규화 과정을 거치게 되면 정규형을 만족하게 됨. 정규형이란 특정 조건을 만족하는 릴레이션의 스키마의 형태를 말하며 제 1 정규형, 제 2 정규형, 제 3 정규형, ...등이 존재함

#### 나쁜 릴레이션은 어떻게 파악하는가?

엔티티를 구성하고 있는 애트리뷰트 간에 함수적 종속성 (Functional Dependency)을 판단한다. 판단된 함수적 종속성은 좋은 릴레이션 설계의 정형적 기준으로 사용됨. 즉, 각각의 정규형마다 어떠한 함수적 종속성을 만족하는지에 다라 정규형이 정의되고, 그 정규형을 만족하지 못하는 정규형을 나쁜 릴레이션으로 파악

#### 함수적 종속성이란?

```
x(결정자) -> y(종속자) : x이면 y이다 = x는 y를 결정한다 = y는 x의 종속된다
-- x를 정했을 때, y의 값이 오직 1개 이면 함수적 종속성 --
```

애트리뷰트 데이터들의 의미와 애트리뷰트들 간의 상호 관계로부터 유도되는 제약조건의 일종. X와 Y를 임의의 애트리뷰트 집합이라고 할 때, X의 값이 Y의 값을 유일하게(Unique) 결정한다면 "X는 Y를 함수적으로 결정한다"라고 함. 함수적 종속성은 실세계에서 존재하는 애트리뷰트들 사이의 제약조건으로부터 유도됨. 또한 각종 추론 규칙에 따라서 애트리뷰트들간의 함수적 종속성을 판단할 수 있음

### 정규화가 필요한 이유

- 잘못된 테이블 설계로 인해 Anomaly (이상 현상)가 나타나기 때문

<br>

### 정규화 과정

```
비정규 Relation
	↓-----도메인이 원자 값
제 1 정규형
	↓-----부분 함수적 종속 제거
제 2 정규형
	↓-----이행적 함수 종속 제거
제 3 정규형
	↓-----결정자이면서 후보키가 아닌 것 제거
   BCNF
	↓-----다치 종속 제거
제 4 정규형
	↓-----조인 종속성 이용
제 5 정규형
```

## 제 1 정규형

애트리뷰트의 도메인이 오직 `원자값`만을 포함하고, 튜플은 모든 애트리뷰트가 도메인에 속하는 하나의 값을 가져야 함. 즉 복합 애트리뷰트, 다중값 애트리뷰트, 중첩 릴레이션 등 비 원자적인 애트리뷰트들을 허용하지 않는 릴레이션 형태를 말함

**원자값** : 더 이상 쪼갤 수 없는 값

## 제 2 정규형

모든 비주요 애트리뷰트들이 주요 애트리뷰트에 대해서 **완전 함수 종속이면 제 2 정규형을 만족한다**고 볼 수 있음. 완전 함수적 종속이란 `X -> Y` 라고 가정했을 때, X의 어떠한 애트리뷰트라도 제거하면 더 이상 함수적 종속성이 성립하지 않는 경우를 말함. 즉, 키가 아닌 열들이 각각 후보키에 대해 결정되는 릴레이션 형태를 말함

## 제 3 정규형

어떠한 비주요 애트리뷰트도 기본키에 대해서 **이행적으로 종속되지 않으면 제 3 정규형을 만족한다**고 볼 수 있음. 이행적 함수 종속이란 `X -> Y`, `Y -> Z` 의 경우에 의해서 추론될 수 있는 `X -> Z`의 종속관계를 말함. 즉, 비주요 애트리뷰트가 비주요 애트리뷰트에 의해 종속되는 경우가 없는 릴레이션 형태를 말함

## BCNF(Boyce-Codd) 정규형

여러 후보 키가 존재하는 릴레이션에 해당하는 정규화 내용. 복잡한 식별자 관계에 의해 발생하는 문제를 해결하기 위해 제 3 정규형을 보완하는데 의미가 있음. 비주요 애트리뷰트가 후보키의 일부를 결정하는 분해하는 과정을 말함

- 모든 제 2 정규형 릴레이션은 제 1 정규형을 갖는다
- 모든 제 3 정규형 릴레이션은 제 2 정규형을 갖는다
- 모든 BCNF 정규형 릴레이션은 제 3 정규형을 갖는다

수 많은 정규형이 있지만, 관계 데이터베이스 설계의 목표는 각 릴레이션이 3NF(or BCNF)를 갖게 하는 것

<BR>

### 장점

1. 데이터베이스 변경 시 이상 현상 제거
2. 데이터베이스 구조 확장 시 재 디자인 최소화 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 됨. 이는 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되며 응용프로그램의 생명을 연장시킴
3. 사용자에게 데이터 모델을 더욱 의미있게 제공

<BR>

### 단점

1. 릴레이션의 분해로 인해 릴레이션 간의 연산(JOIN 연산)이 많아짐. 이로 인해 질의에 대한 응답 시간이 느려질 수 있음
2. 정규화를 수행한다는 것은 데이터를 결정하는 결정자에 의해 함수적 종속성을 가지고 있는 일반 속성을 의존자로 하여 입력/수정/삭제 이상을 제거하는 것.  데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과
3. 따라서 정규화된 테이블은 데이터를 처리할 때 속도가 빨라질 수도, 느려질 수도 있음

# 트랜잭션

- 작업의 **완전성**을 보장
- **즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능**
- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
- **상태를 변화시킨다는 것은 SQL 질의어를 통해 DB에 접근하는 것**
- 작업 단위 : **많은 SQL 명령문들을 사람이 정하는 기준에 따라 정하는것**
- Ex. 게시판에서 사용자가 글을 작성하고 올리기 버튼을 누른 후 게시판에 다시 돌아오면, 게시판에 내가 쓴 글이 업데이트된 상태를 불 수 있음
- 이때 DB 작업
  - 올리기 버튼을 누름 : INSERT문을 사용해 사용자가 입력한 게시글 데이터를 옮김
  - 게시판 새로 구성 : SELECT문을 사용해 최신 정보를 유지
- 현재 작업 단위 : INSERT문 + SELECT문
  - 이를 통틀어 하나의 트랜잭션이라고 함

### 주의 점

- 꼭 필요한 최소의 코드에만 적용하는 것이 좋음. 즉 트랜잭션의 범위를 최소화하라는 의미

<BR>

### 트랜잭션 특징 (ACID)

- 트랜잭션이 **안전하게 수행된다는 것을 보장하기 위한 성질**
- **동시성제어**와 **회복 기법**을 활용하여 보장

#### 원자성 (Atomicity)

- **만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며, 아무런 문제가 발생되지 않았을 경우에만 모든 작업이 수행되어야 함**
- 하나의 트랜잭션은 하나의 원자적 수행단위
- 트랜잭션은 **완전히 수행**되거나 **전혀 수행되지 않아야 함** (All or Nothing)
- **회복 기법**을 활용하여 보장

#### 일관성 (Consistency)

- **트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 함**
- 트랜잭션을 완전히 실행하면 데이터베이스를 하나의 **일관된 상태**에서 또 다른 **일관된 상태**로 바꿔야 함
- 즉, 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 함
- **동시성제어**와 **회복 기법**을 활용하여 보장

#### 독립성, 고립성 (Isolation)

- 하나의 트랜잭션은 다른 트랜잭션과는 **독립적으로 실행되는 것처럼 보여야 함**
- **하나의 트랜잭션 실행 시 동시에 실행중인 다른 트랜잭션의 간섭을 받으면 안됨**
- 성능 관련 문제로 인해 유연하게 조절할 수 있도록 고립 수준을 단계별로 구분
- **동시성 제어**를 활용하여 보장

#### 지속성 (Durability)

- 트랜잭션이 성공적으로 완료되었으면, 시스템이 고장나더라도 **결과는 영구적으로 반영되어야 함**
- **회복 기법**을 활용하여 보장

<br>

### Commit

- 하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성 있는 상태일 때 이를 알려주기 위해 사용하는 연산
- 모든 작업을 마쳤을 경우 Commit

<br>

### Rollback

- 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진 경우
- 트랜잭션이 정상적으로 종료되지 않았을 때, last consistent state(ex. 트랜잭션의 시작 생태)로 roll back할 수 있음
- 중단된 경우 처음부터 다시 실행하는 Rollback

<br>

# 교착상태

### 교착상태란

- 두 개 이상의 트랜잭션이 특정 자원의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태
- 복수의 트랜잭션 사용시 발생 가능

```sql
Transaction 1> create table B (i1 int not null primary key) engine = innodb;
Transaction 2> create table A (i1 int not null primary key) engine = innodb;

Transaction 1> start transaction; insert into B values(1);
Transaction 2> start transaction; insert into A values(1);
```

트랜잭션 1이 테이블 B의 첫번째 행의 잠금을 얻고, 트랜잭션 2도 테이블 A의 첫번째 행의 잠금을 얻었다고 가정

트랜잭션을 commit 하지 않은 채 서로의 첫번째 행에 대한 잠금을 요청하면

```sql
Transaction 1> insert into A values(1);
Transaction 2> insert into B values(1);
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```

Deadlock이 발생

<br>

### 교착상태의 빈도를 낮추는 방법

- 트랜잭션을 자주 커밋함
- 정해진 순서로 테이블에 접근. 위에서 트랜잭션 1이 테이블 B -> A 의 순으로 접근했고, 트랜잭션 2는 테이블 A -> B의 순으로 접근했다. 트랜잭션들이 동일한 테이블 순으로 접근하게 함
- 한 테이블의 복수 행을 복수의 연결에서 순서 없이 갱신하면 교착상태가 발생하기 쉽다. 이 경우에는 테이블 단위의 잠금을 획득해 갱신을 직렬화 하면 동시성은 떨어지지만 교착상태를 회피할 수 있음

<BR>

# 낙관적 락, 비관적 락

```
1. A가 R1을 읽는다.
2. B가 R1을 읽는다.
3. A가 R1을 수정한다.
4. B가 R1을 수정한다.
```

- 일반적으로 B는 A의 수정이 끝나기전의 데이터를 읽었기 때문에 **최종적으로는 B의 수정사항만 반영됨**
- 이처럼 동시성 프로그래밍에서 고려해야할 사항으로 트랜잭션 처리가 존재

<BR>

### 낙관적 락 (OptimisticLock)

- 트랜잭션 대부분 충돌이 발생하지 않는다고 가정하는 방법
- 비선점 락
- 락을 해야하는 상황이 발생하면 대응함
- 읽는 시점에 락을 사용하지 않기 때문에 데이터를 수정하는 시점에 다른 사용자에 의해 데이터가 변경되었는지 변경여부를 확인해야 함
- 레코드를 읽고 버전 번호를 기록하고 레코드를 다시 쓰기 전에 버전이 변경되지 않았는지 확인하는 전략
- 낙관적 락은 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌 여부를 알 수 없음

<br>

### 비관적 락 (PessimisticLock)

- 자원에 대한 동시 요청이 발생하여 일관성에 문제가 생길 것이라고 비관적으로 생각하고 이를 방지하기 위해 **우선 락을 거는 방식**
- 선점 락
- **무조건 잠그고 작업**
- 완료할때까지 독점 사용을 위해 레코드를 잠그는 전략

<br>

# Isolation level

### 필요성

데이터베이스는 ACID 특징과 같이 트랜잭션이 독립적인 수행을 하도록 한다.

따라서 Locking을 통해, 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하도록 막는 것이 필요하다.

하지만 무조건 Locking으로 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현하게 되면 데이터베이스의 성능은 떨어지게 될 것이다. 

그렇다고 해서 성능을 높이기 위해 Locking의 범위를 줄인다면, 잘못된 값이 처리될 문제가 발생하게 된다.

**따라서 최대한 효율적인 Locking 방법이 필요**

<br>

### 종류

1. Read Uncommitted (레벨 0)

   ```
   사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안, 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터 B를 읽을 수 있다
   ```

   - **어떤 트랜잭션이 Commit, Rollback 으로 종료되지 않아도 다른 트랜잭션에서 데이터 참조 가능**
   - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 계층
   - **이로 인해 다른 트랜잭션이 갱신하면서 설정한 배타적 락을 무시하고, 변경 중인 데이터를 참조하거나, 참조중인 데이터를 변경하는 문제, 추가 삽입되는 데이터 문제 등이 발생**
   - 데이터베이스의 일관성을 유지하는 것이 불가능함

2. Read Committed (레벨 1)

   ```
   사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안, 사용자2는 해당 데이터에 접근이 불가능함
   ```

   - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 됨
   - Commit이 이루어진 트랜잭션만 조회 가능
   - SQL 서버가 디폴트로 사용하는 Isolation level
   - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 계층
   - **단, 공유 락이 트랜잭션이 종료되는 Commit, Rollback 시점까지 유지되는 것이 아닌 SELECT 문이 처리되는 순간만 설정되므로 반복 읽기시 중간에 데이터 갱신, 삽입에 의한 문제 발생**

3. Repeatable Read (레벨 2)

   - 트랜잭션이 범위 내에서 조회한 데이터 내용이 항상 동일함을 보장함
   - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
   - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shard Lock이 걸리는 계층
   - 단, SELECT나 UPDATE 등을 이용해 현재 존재하는 데이터에 대해서만 락을 설정하므로 SELECT 등을 이용해 범위 데이터를 처리 할 때, 범위 내에 있으나 존재 하지 않아 락이 걸리지 않은 영역에 데이터가 추가로 삽입되면 문제 발생

4. Serializable (레벨 3)

   - 완벽한 읽기 일관성 모드를 제공함
   - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능
   - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shard Lock이 걸리는 계층
   - 최고 단계 고립 수준으로 일관성이 보장되지만 성능이 안 좋음
   - 따라서 동시성이 중요한 DB에서는 거의 사용하지 않고, 낮은 단계의 격리 수준과 함께 애플리케이션 단계에서 낙관적 락, 비관적 락 등을 활용해 처리하는 경우가 많음

* 격리 수준을 **높일 경우 성능이 저하**되지만, 동시성 제어로 인해 **일관성이 보장됨**
* 격리 수준을 **낮출 경우 성능은 향상**되지만, 동시성 제어로 문제가 생겨 **일관성이 보장되지 않을 수 있음**

<BR>

# SQL (관계형 DB)

- SQL을 사용하면 RDBMS에서 데이터를 저장, 수정, 삭제 및 검색할 수 있음
- 관계형 데이터베이스에는 핵심적인 두 가지 특징 존재
  - 데이터는 정해진 데이터 스키마에 따라 테이블에 저장됨
  - 데이터는 관계를 통해 여러 테이블에 분산됨

데이터는 테이블에 레코드로 저장되는데, 각 테이블마다 명확하게 정의된 구조가 있다. 해당 구조는 필드의 이름과 데이터 유형으로 정의

**따라서 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.** 즉, 스키마를 수정하지 않는 이상은 정해진 구조에 맞는 레코드만 추가가 가능한 것이 관계형 데이터베이스의 특징 중 하나

또한, 데이터의 중복을 피하기 위해 **관계**를 이용

<BR>

# NoSQL (비관계형 DB)

- 관계형 DB의 반대
- 스키마도 없고 관계도 없음
- NoSQL 에서는 레코드를 문서라고 부름
- 대량의 분산된 데이터를 저장하고 조회하는 데 특화되었음

여기서 SQL과 핵심적인 차이가 있다. SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능

하지만 NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가가 가능하다.

문서는 Json과 비슷한 형태로 가지고 있다. **관계형 데이터베이스처럼 여러 테이블에 나누어담지 않고, 관련 데이터를 동일한 '컬렉션'에 넣는다.** 따라서 여러 테이블에 조인할 필요없이 이미 필요한 모든 것을 갖춘 문서를 작성하는 것이 NoSQL이다.

***조인하고 싶을 때 NoSQL은 어떻게 할까?***

컬렉션을 통해 데이터를 복제하여 각 컬렉션 일부분에 속하는 데이터를 정확하게 산출하도록 한다. 하지만, 이러면 데이터가 중복되어 서로 영향을 줄 위험이 있다. 따라서 **조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 때, NoSQL을 쓰면 상당히 효율적이다.**

### 데이터 저장 방식

1. Key-Value Model

   가장 기본적인 형태의 NoSQL 이며 키 하나로 데이터 하나를 저장하고 조회할 수 있는 단일 키-값 구조를 갖는다. 단순한 저장구조로 인하여 복잡한 조회 연산을 지원하지 않는다. 또한 고속 읽기와 쓰기에 최적화된 경우가 많다. 사용자의 프로필 정보, 웹 서버 클러스터를 위한 세션 정보, 장바구니 정보, URL 단축 정보 저장 등에 사용한다. 하나의 서비스 요청에 다수의 데이터 조회 및 수정 연산이 발생하면 트랜잭션 처리가 불가능하여 데이터 정합성을 보장할 수 없다.

2. Document Model

   키-값 모델을 개념적으로 확장한 구조로 하나의 키에 하나의 구조화된 문서를 저장하고 조회한다. 논리적인 데이터 저장과 조회 방법이 관계형 데이터베이스와 유사하다. 키는 문서에 대한 ID로 표현된다. 또한 저장된 문서를 컬렉션으로 관리하며 문서 저장과 동시에 문서 ID에 대한 인덱스를 생성한다. 문서 ID 에 대한 인덱스를 사용하여 O(1) 시간 안에 문서를 조회할 수 있다.

   대부분의 문서 모델 NoSQL은 B 트리 인덱스를 사용하여 2차 인덱스를 생성한다. B 트리는 크기가 커지면 커질수록 새로운 데이터를 입력하거나 삭제할 때 성능이 떨어지게 된다. 그렇기 때문에 읽기와 쓰기의 비율이 7:3 정도일 때 가장 좋은 성능을 보인다. 중앙 집중식 로그 저장, 타임라인 저장, 통계 정보 저장 등에 사용된다. Ex. MongoDB

3. Column Model

   하나의 키에 여러 개의 컬럼 이름과 컬럼 값의 쌍으로 이루어진 데이터를 저장하고 조회한다. 모든 컬럼은 항상 타임 스탬프 값과 함께 저장된다. 구글의 빅테이블이 대표적인 예로 차후 컬럼형 NoSQL은 빅테이블의 영향을 받았다. 이러한 이유로 Row key, Column Key, Column Family 같은 빅테이블 개념이 공통적으로 사용된다. 저장의 기본 단위는 컬럼으로 컬럼은 컬럼 이름과 컬럼 값, 타임스탬프로 구성된다. 이러한 컬럼들의 집합이 로우(Row)이며, 로우키(Row key)는 각 로우를 유일하게 식별하는 값이다. 이러한 로우들의 집합은 키 스페이스(Key Space)가 된다.

   대부분의 컬럼 모델 NoSQL 은 쓰기와 읽기 중에 쓰기에 더 특화되어 있다. 데이터를 먼저 커밋로그와 메모리에 저장한 후 응답하기 때문에 빠른 응답속도를 제공한다. 그렇기 때문에 읽기 연산 대비 쓰기 연산이 많은 서비스나 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다. 채팅 내용 저장, 실시간 분석을 위한 데이터 저장소 등의 서비스 구현에 적합하다.

<BR>

### 확장 개념

- 수직적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것 (Ex. CPU 업그레이드)
- 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미 (하나의 데이터베이스에서 작동하지만, 여러 호스트에서 작동)

데이터 저장 방식으로 인해 ***SQL DB는 일반적으로 수직적 확장만 지원***, ***NoSQL DB는 수평적 확장이 가능***

<BR>

### SQL 장/단점

#### 장점

- 명확하게 정의된 스키마, 데이터 무결성 보장
- 관계는 각 데이터를 중복 없이 한번만 저장
- 하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에, 다른 테이블에서 부정확한 데이터를 다룰 위험이 줄어듬

#### 단점

- 덜 유연함. 데이터 스키마를 사전에 계획하고 알려야 함
- 나중에 수정하기 힘듦
- 관계를 맺고 있어서 조인문이 많은 복잡한 쿼리가 만들어질 수 있음
- 대체로 수직적 확장만 가능

###  NoSQL 장/단점

#### 장점

- 스키마가 없어서 유연함. 언제든지 저장된 데이터를 조정하고 새로운 필드 추가가 가능
- **데이터는 애플리케이션이 필요로 하는 형식으로 저장됨**. 데이터를 읽어오는 속도가 빨라짐
- 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청 처리가 가능함

#### 단점

- 유연성으로 인해 데이터 구조 결정을 미루게 될 수 있음
- 데이터 중복을 계속 업데이트 해야 함
- 데이터가 여러 컬렉션에 중복되어 있기 때문에, 수정시 모든 컬렉션에서 수행해야 함 (SQL에서는 중복 데이터가 없으므로 한번만 수행이 가능)
- 인덱스 구조를 메모리에 저장하기 때문에 많은 인덱스를 사용하면 충분한 메모리가 필요

### SQL DB 사용이 더 좋은 경우

- 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우 (NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율)
- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### NoSQL DB 사용이 더 좋은 경우

- 정확한 데이터 구조를 알 수 없거나 변경, 확장이 될 수 있는 경우
- 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
- 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)
