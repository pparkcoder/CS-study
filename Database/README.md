# 데이터 베이스

### 용어 정리

#### 테이블 (Table)

- 행과 열로 이루어진 집합
- 일반적인 데이터베이스에서는 행과 열만 있으면 테이블
- **관계형 데이터베이스에서는 특별한 제약을 추가해서 릴레이션 (Relation) 이라고 부름**
- 아래 조건을 충족하는 테이블만이 릴레이션이 될 수 있기 때문에 **모든 릴레이션은 -> 테이블 (O) , 모든 테이블 -> 릴레이션 (X)**
  1. 모든 값은 유일한 값을 가짐
  2. 하나의 릴레이션에서 중복되는 행이 존재하면 안됨

#### 행 (Row)

- 한 객체에 대한 정보를 가짐
- 관계형 데이터베이스에서는 **튜플** 또는 **레코드**라고 부름

#### 열 (Colum)

- 테이블의 속성을 의미하며, 열을 구성하는 값들은 같은 **도메인 (Domain)** 으로 되어 있음
- 관계형 데이터베이스에서는 **속성** 이라고 부름

#### 도메인 (Domain)

- 데이터베이스에서 필드(Field)에 채워질 수 있는 값의 집합
- 도메인이 1에서 10사이의 정수인 속성의 필드에 11이나 -1처럼 도메인을 벗어나는 값 또는 아예 다른 자료형이 들어갈 수 없음

#### 스키마 (Schema)

- 데이터베이스를 구성하는 데이터 개체 (Entity), 속성 (Attribute), 관계 (Relationship) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건 등에 관해 전반적으로 정의
- 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 구분
- DBMS는 외부 스키마에 명세된 사용자의 요구를 개념 스키마 형태로 변환하고, 이를 다시 내부 스키마 형태로 변환

![](https://t1.daumcdn.net/cfile/tistory/9936823A5B698C4023){:.alignleft}

1. 외부 스키마
   - **사용자의 입장에서 정의한 데이터베이스의 논리적 구조**
   - 데이터들은 어떤 형식, 구조, 화면을 통해 사용자에게 보여줄 것인가에 대한 명세를 말하며, 하나의 데이터베이스에는 여러 개의 외부 스키마가 있을 수 있음
   - 일반 사용자에게는 질의어를 이용해 DB를 쉽게 사용할 수 있도록 하고 응용 프로그래머는 언어를 사용해 DB에 접근하도록 함
2. 개념 스키마
   - 조직 전체를 관장하는 입장에서 DB를 정의한 스키마
   - **DB에 대한 모든 논리적 구조를 기술하기 때문에 데이터베이스에 하나만 존재하며, 통상 스키마라고 하면 개념 스키마를 의미**
3. 내부 스키마
   - 데이터베이스가 어떻게 저장 장치에 저장될 지에 대한 명세
   - 물리적인 저장 장치와 데이터베이스 간의 관계를 정의하므로 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마

<BR>

### 데이터 베이스

특정 조직의 업무를 수행하는 데 필요한 상호 관련된 데이터들의 모임

1. 통합된 데이터 (Integrated Data) : 자료의 중복을 배제한 데이터의 모임
2. 저장된 데이터 (Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
3. 운영 데이터 (Operational Data) : 조직의 고유한 업무를 수행하는 데 존재 가치가 확실하고 없어서는 안될 반드시 필요한 자료
4. 공용 데이터 (Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료

### 특징

1. 실시간 접근성 (Real-Time Accessibility) : 수시적이고 비정형적인 질의에 대하여 **실시간 처리 응답이 가능해야 함**
2. 계속적인 변화 (Continuous Evolution) : 데이터베이스의 상태는 동적. 즉 새로운 데이터의 삽입, 삭제, 갱신은 **항상 최신의 데이터를 유지**
3. 동시공용 (Concurrent Sharing) : 데이터베이스는 서로 다른 목적을 가진 여러 응용자들을 위한 것이므로, **다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야 함**
4. 내용에 의한 참조 (Content Reference) : 데이터베이스에 있는 데이터를 참조할 때 데이터 레코드의 주소나 위치에 의해서가 아니라, **사용자가 요구하는 데이터 내용으로 데이터를 찾음**

<br>

# Key

- 검색이나 정렬 시 Tuple을 구분할 수 있는 기준이 되는 Attribute

![](https://user-images.githubusercontent.com/33534771/75773133-a4d02680-5d90-11ea-8ad0-ac4b85e438d2.png)

### 1. 후보키 (Candidate Key)

- 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별할 수 있는 속성들의 부분 집합을 의미
- **기본키로 사용할 수 있는 속성들**
- **모든 릴레이션은 반드시 하나 이상의 후보키를 가져야 함**
- 릴레이션에 있는 모든 튜플에 대해서 **유일성과 최소성을 만족**시켜야 함
  - 유일성 : key로 하나의 튜플을 유일하게 식별할 수 있음
  - 최소성 : 꼭 필요한 속성으로만 구성

**학생 릴레이션에서 학번이나 주민번호는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키. 즉, 기본키가 될 수 있는 키들을 후보키**

### 2.기본키 (Primary Key)

- **후보키 중 선택한 Main Key**
- 한 릴레이션에서 **특정 튜플을 유일하게 구별할 수 있는 속성**
- **Null 값을 가질 수 없음 (개체 무결성의 첫 번째 조건**
- **기본키로 정의된 속성에는 동일한 값이 중복되어 저장될 수 없음 (개체 무결성의 두 번째 조건)**
- 아래 조건을 만족해야 함
  - 유일성 : 기본키를 구성하는 컬럼은 릴레이션에서 레코드를 식별할 수 있도록 유일해야 함
  - 최소성 : 유일성을 만족하는 한도 내에서 최소한의 컬럼으로 구성되어야 함
  - 개체 무결성 : 기본키가 가지고 있는 값의 유일성을 보장받아야 함

**학생 릴레이션에서 학번이나 주민번호가 기본키가 될 수 있고, 수강 릴레이션에는 학번+과목병으로 조합해야 기본키가 만들어 질 수 있음. 왜냐하면 수강 릴레이션에서는 학번 속성과 과목명 속성 각각은 다른 튜플들과 구별되지 않기 때문**

### 3. 대체키 (Alternate Key) , 보조키

- **후보키가 둘 이상일 때, 기본키를 제외한 나머지 후보키**

**학생 릴레이션에서 학번을 키본키로 정하면 주민번호는 대체키**

### 4. 슈퍼키 (Super Key)

- 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타내지 않음
- 릴레이션을 구성하는 모든 튜플에 대해서 **유일성은 만족하지만, 최소성은 만족시키지 못함**

**[학생] 릴레이션에서는 학번, 주민번호, 학번+주민번호, 학번+주민번호+성명  등으로 슈퍼키를 구성할 수 있다. 또한, 여기서 최소성을 만족시키지 못한다는 말은  학번+주민번호+성명 이 슈퍼키인 경우, 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만,  성명 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못함**

즉, 뭉쳤을 경우 유일성이 생기고 흩어지면 몇몇 속성들은 독단적으로 유일성이 있는 키로 사용할 수 없음. 이것을 최소성을 만족하지 못한다고 함.

### 5. 외래키 (Foreign Key)

- 관계(Relation)를 맺고 있는 릴레이션 R1,R2에서 릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성을 외래키라고 한다.
- 외래키는 **참조되는 릴레이션의 기본키와 대응되어 릴레이션 간에 참조 관계를 표현하는 데 중요한 도구로 사용된다**.
- **외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없다**.(참조 무결성의 조건)

[수강] 릴레이션이 [학생] 릴레이션을 참조하고 있으므로, [학생] 릴레이션의 **학번**은 기본키이고, [수강] 릴레이션의 **학번**은 외래키이다.

즉, 각 릴레이션의 입장에서 속성은 기본키가 되기도 하고, 외래키가 되기도 한다.

-> [수강] 릴레이션의 **학번**에는 [학생] 릴레이션의 **학번**에 없는 값은 입력할 수 없다.

<br>

# 쿼리 관련

[SQL문](https://github.com/pparkcoder/TechnicalNote/blob/master/database/DBQuery.md)

[DDL, DML, DCL](https://github.com/pparkcoder/TechnicalNote/blob/master/database/DDLAndDMLAndDCL.md)

# Index

### Index란

인덱스는 말 그대로 책의 맨 처음 또는 맨 마지막에 있는 색인. 데이터는 책의 내용이고, 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호가 될 것. DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸림. 그래서 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것

DBMS의 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 탐색하는데는 빠르지만, ***새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려짐***. 결론적으로 **DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능**. SELECT 쿼리 문장의 WHERE 조건절에 사용되는 컬럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과

<BR>

### Index의 성능과 고려해야 할 사항

SELECT 쿼리의 성능을 월등히 향상시키는 인덱스는 항상 좋은 것인가? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 인덱스를 생성해두면 빨라지지 않을까? **그렇지 않음**. 인덱스를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생.

INSERT의 경우 인덱스에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따름.

DELETE의 경우 인덱스에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됨. 즉 row의 수는 그대로임. 실제 데이터는 10만건인데, 데이터가 100만건이 있는 결과를 낳을 수 있음.

UPDATE의 경우는 INSERT의 경우, DELETE의 경우의 문제점을 동시에 수반. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념. 즉 변경 전 데이터는 삭제되지 않고 INSERT로 인한 split도 발생

하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고 만들면 비효율적인 데이터의 형식이 존재

`이름,나이,성별` 세 가지 필드를 갖고 있는 테이블의 경우, 이름은 온갖 경우의 수가 존재할 것이며 나이는 INT 타입을 갖을 것이고, 성별은 `남,녀` 두 가지 경우에 대해서만 데이터가 존재할 것. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까? 결론은 `이름`에 대해서만 인덱스를 생성하면 효율적. 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정하면, 값의 range가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O가 발생하기 때문에 그만큼 비효율

<BR>

# JOIN

### JOIN 이란

- 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법
- 테이블을 연결하려면 **적어도 하나의 컬럼을 서로 공유하고 있어야** 하므로 이를 이용하여 데이터 검색에 활용

<BR>

### JOIN 종류

1. **INNER JOIN**

![](https://user-images.githubusercontent.com/33534771/75853566-c1706b00-5e31-11ea-83bc-1e2ebe4d9f61.png) 

- 쉽게 말해 **교집합**

- 기준 테이블과 JOIN 한 테이블의 **중복된 값**을 보여줌

- 결과값은 A 테이블과 B 테이블 모두 가지고 있는 데이터만 검색

- 표현 방법

  - **EQUI JOIN (동등조인)**

    - ```sql
      SELECT *
      FROM EMPLOYEE, DEPARTMENT
      WHERE EMPLOYEE.DepartmentID = DEPARTMENT.DepartmentID
      ```

    - 연산자(=) 를 사용해서 EQUI JOIN 이라고 부름

  - **명시적인 표현**

    - ```SQL
      SELECT *
      FROM EMPLOYEE INNER JOIN DEPARTMENT
      ON EMPLOYEE.DepartmentID = DEPARTMENT.DepartmentID
      ```

    - INNER JOIN 표시가 있다면 WHERE 절에서 사용하던 JOIN 조건을 FROM 절에 사용한다는 뜻

    - **USING, ON 조건절을 필수로 사용**

  - **USING 조건절**

    - ```SQL
      SELECT *
      FROM EMP JOIN DEPT USING(DEPTNO)
      ```

    - 원하는 컬럼에 대해서만 선택적으로 EQUI JOIN

    - ALIAS나 테이블 이름과 같은 접두사를 사용할 수 없음

    - USING 조건에는 1개 이상의 컬럼을 정의할 수 있음

  - **ON 조건절**

    - ```SQL
      SELCT T.TEAM_NAME, S.STADIUM_ID, S.STADIUM_NAME
      FROM TEAM T JOIN STADIUM S
      ON(T.STADIUM_ID = S.HOMETEAM_ID); -- STADIUM_ID와 HOMETEAM_ID는 같은 데이터이지만 컬럼 이름이 다름
      ```

    - **컬럼명이 다르더라도 JOIN 조건을 사용할 수 있음**

    - 테이블이 많이 사용될 경우 가독성이 떨어질 수 있음

  <BR>

2. **OUTER JOIN**

- JOIN 조건에서 **테이블간에 한 쪽에만 데이터가 있는 경우, 데이터가 있는 테이블 쪽의 모든 내용을 보여주는 것**

- 조인 조건에 만족하지 않아도 해당 행을 출력하고 싶을 때 사용

- **USING, ON 조건절을 필수적으로 사용**

- **항상 기준이 되는 테이블이 드라이빙 테이블이 됨**. 드라이빙 테이블에 따라 쿼리의 성능이나 튜닝에 많은 영향을 끼치기 때문에 **데이터 양 보다는 적은 데이터를 추출하는 테이블을 드라이빙 테이블로 잡는 것이 중요**

- 드라이빙 테이블 : JOIN이 발생했을 때 첫 번째로 ACCESS되는 테이블

- 표현 방법

  - **LEFT OUTER JOIN**

    - ![](https://user-images.githubusercontent.com/33534771/75853627-e238c080-5e31-11ea-89bb-a5afe1058cfd.png) 

    - 왼쪽 테이블을 기준으로 데이터 출력

    - ```SQL
      SELECT A.NAME, B.AGE
      FROM EX_TABLE A
      LEFT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
      ```

    - **결과값은 A 테이블의 모든 값과 A 테이블과 B 테이블의 중복되는 값이 검색**

  - **RIGHT OUTER JOIN**

    - ![](https://user-images.githubusercontent.com/33534771/75853699-f8468100-5e31-11ea-8c0f-5109f2852c59.png) 

    - 오른쪽 테이블을 기준으로 데이터 출력

    - ```SQL
      SELECT A.NAME, B.AGE
      FROM EX_TABLE A
      RIGHT OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
      ```

    - **결과값은 B 테이블의 모든 데이터와 A 테이블과 B 테이블의 중복되는 값이 검색**

  - **FULL OUTER JOIN**

    - ![](https://user-images.githubusercontent.com/33534771/75853732-072d3380-5e32-11ea-8cda-53eb71de966e.png) 

    - 쉽게 말해 **합집합**

    - 사실상, 기준 테이블의 의미가 없음

    - ```SQL
      SELECT A.NAME, B.AGE
      FROM EX_TABLE A
      FULL OUTER JOIN JOIN_TABLE B ON A.NO_EMP = B.NO_EMP
      ```

    -  **A 테이블이 가지고 있는 데이터, B 테이블이 가지고 있는 데이터 모두 검색됨**

    - 중복되는 데이터는 삭제

<BR>

### CROSS JOIN , CROSS PRODUCT

![](https://user-images.githubusercontent.com/33534771/75853764-16ac7c80-5e32-11ea-9942-04adab33ddb2.png) 

- **모든 경우의 수를 전부 표현해주는 방식**
- 기준 테이블이 A일 경우, A의 데이터 한 ROW를 B 테이블 전체와 JOIN 하는 방식
- 결과값은 **N*M**

```SQL
-- 첫 번째 방식 --
SELECT A.NAME, B.AGE
FROM EX_TABLE A
CROSS JOIN JOIN_TABLE B
-- 두 번째 방식 --
SELECT A.NAME, B.AGE
FROM EX_TABLE A, JOIN_TABLE B
```

<BR>

### SELF JOIN, 자가 JOIN

![](https://user-images.githubusercontent.com/33534771/75853799-2926b600-5e32-11ea-94ce-4974aade41ca.png) 

- 자기 자신과 자기 자신을 조인한다는 의미

- 하나의 테이블을 여러번 복사해서 조인한다고 생각

- 자신이 가지고 있는 컬럼을 다양하게 번형시켜 활용할 경우에 자주 사용

- ```SQL
  SELECT e.empno, e.ename, e.job, e.sal, m.empno, m.ename, m.job
  FROM emp e INNER JOIN emp m ON e.mgr = m.empno
  ```





